[{"title":"Android启动流程","path":"/2024/09/26/Android启动流程/","content":"Android启动流程Android源码基于14 一、Android架构 二、启动流程 Boot ROM：用于加载并执行Boot Loader。Android 设备上电后，开始执行固化在 CPU芯片里的 Boot ROM 中的预设代码，程序将 Boot Loader 代码加载到 ROM 中。这一步由芯片厂商负责设计和实现。 Boot Loader：用于将系统代码加载到 RAM 中。具体功能有：检查 RAM、初始化系统的硬件参数等功能，找到 Linux kernel 的代码，设置启动参数，并最终加载到RAM中。 Kernel：Linux 内核开始启动，初始化各种软硬件环境、加载驱动程序、挂载根文件系统、并执行 init 程序，由此开启 Android 的世界。 Init：内核初始化完成后，会启动名为init的用户空间进程。init进程是Android系统的第一个用户空间进程，它负责系统的进一步初始化和启动。init进程会读取系统配置文件（例如 init.rc），并根据其中的指令启动系统服务和应用程序。 12345init进程会孵化出ueventd、logd、healthd、installd、adbd、lmkd等用户守护进程；init进程还启动servicemanager(binder服务管家)、bootanim(开机动画)等重要服务init进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程(即虚拟机进程)，Zygote是所有Java进程的父进程，Zygote进程本身是由init进程孵化而来的。 Zygote：Zygote 是 Android 系统的启动进程，Zygote 会启动 System Servers。 System Servers：是Android系统的核心，负责启动和管理整个Java FrameWork，包含ActivityManagerService， WorkManagerService，PagerManagerService，PowerManagerService等服务。 三、Zygote进程(孵化器进程)init进程通过解析init.rc文件来启动各种服务和进程，包括Zygote 3.1 init.rc脚本解析init.rc源码地址 1234567891011121314151617/*system/core/rootdir/init.rc*/import /system/etc/init/hw/init.$&#123;ro.zygote&#125;.rc...on late-init # Now we can start zygote for devices with file based encryption trigger zygote-start // 1. 触发启动zygote...on zygote-start &amp;&amp; property:ro.crypto.state=encrypted &amp;&amp; property:ro.crypto.type=file wait_for_prop odsign.verification.done 1 # A/B update verifier that marks a successful boot. exec_start update_verifier_nonencrypted start statsd start netd start zygote // 2.启动zygote服务 start zygote_secondary... $&#123;ro.zygote&#125;的取值有4种，在init.rc的同级目录system&#x2F;core&#x2F;rootdir&#x2F;下，现在普遍使用的是init.zygote64_32.rc 12345678910111213141516171819202122232425# service zygote: 定义一个名为zygote的服务# /system/bin/app_process64： 这是启动Zygote进程的可执行文件# --start-system-server：Zygote进程启动后需要启动system_server进程，ZygoteInit.java会对参数进行处理service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote class main priority -20 user root group root readproc reserved_disk socket zygote stream 660 root system # 创建一个名为zygote的socket，用于其他进程与Zygote进程通信。 socket usap_pool_primary stream 660 root system onrestart exec_background - system system -- /system/bin/vdc volume abort_fuse onrestart write /sys/power/state on # NOTE: If the wakelock name here is changed, then also # update it in SystemSuspend.cpp #当zygote服务重启时，系统应重启的功能 onrestart write /sys/power/wake_lock zygote_kwl onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart media.tuner onrestart restart netd onrestart restart wificond task_profiles ProcessCapacityHigh MaxPerformance critical window=$&#123;zygote.critical_window.minute:-off&#125; target=zygote-fatal 3.2 启动Zygote进程init进程启动后，通过fork和execv来启动Zygote进程，如下简化代码所示： service.cpp源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354static bool ExpandArgsAndExecv(const std::vector&lt;std::string&gt;&amp; args, bool sigstop) &#123; std::vector&lt;std::string&gt; expanded_args; std::vector&lt;char*&gt; c_strings; expanded_args.resize(args.size()); c_strings.push_back(const_cast&lt;char*&gt;(args[0].data())); for (std::size_t i = 1; i &lt; args.size(); ++i) &#123; auto expanded_arg = ExpandProps(args[i]); if (!expanded_arg.ok()) &#123; LOG(FATAL) &lt;&lt; args[0] &lt;&lt; &quot;: cannot expand arguments&#x27;: &quot; &lt;&lt; expanded_arg.error(); &#125; expanded_args[i] = *expanded_arg; c_strings.push_back(expanded_args[i].data()); &#125; c_strings.push_back(nullptr); if (sigstop) &#123; kill(getpid(), SIGSTOP); &#125; // 2. c_strings[0]是执行程序路径，即如果启动的是zygote服务时，execve会运行/system/bin/app_process64 return execv(c_strings[0], c_strings.data()) == 0;&#125;void Service::RunService(const std::vector&lt;Descriptor&gt;&amp; descriptors, InterprocessFifo cgroups_activated, InterprocessFifo setsid_finished) &#123; ... if (!ExpandArgsAndExecv(args_, sigstop_)) &#123; PLOG(ERROR) &lt;&lt; &quot;cannot execv(&#x27;&quot; &lt;&lt; args_[0] &lt;&lt; &quot;&#x27;). See the &#x27;Debugging init&#x27; section of init&#x27;s README.md for tips&quot;; &#125;&#125;Result&lt;void&gt; Service::Start() &#123; ... pid_t pid = -1; if (namespaces_.flags) &#123; pid = clone(nullptr, nullptr, namespaces_.flags | SIGCHLD, nullptr); &#125; else &#123; pid = fork(); // 1.fork创建service进程（也就是zygote进程） &#125; if (pid == 0) &#123; umask(077); cgroups_activated.CloseWriteFd(); setsid_finished.CloseReadFd(); RunService(descriptors, std::move(cgroups_activated), std::move(setsid_finished)); _exit(127); &#125; else &#123; cgroups_activated.CloseReadFd(); setsid_finished.CloseWriteFd(); &#125; ...&#125; 3.3 zygote进程3.3.1 native层：app_process启动zygote.main&#x2F;system&#x2F;bin&#x2F;app_process是Android中的一个关键可执行文件，负责启动Zygote进程和应用进程。 app_process源码地址 12345678910111213141516171819202122232425262728293031/*frameworks/base/cmds/app_process/app_main.cpp*/int main(int argc, char* const argv[])&#123; ... // Parse runtime arguments. Stop at first unrecognized option. bool zygote = false; ... while (i &lt; argc) &#123; const char* arg = argv[i++]; if (strcmp(arg, &quot;--zygote&quot;) == 0) &#123; zygote = true; // 参数标识启动zygote进程 niceName = ZYGOTE_NICE_NAME; &#125; else if (strcmp(arg, &quot;--start-system-server&quot;) == 0) &#123; startSystemServer = true; //参数标识启动system_server进程 &#125; ... &#125; ... if (!niceName.isEmpty()) &#123; runtime.setArgv0(niceName.string(), true /* setProcName */); // 进程名app_process修改为zygote &#125; if (zygote) &#123; // 启动Zygote，执行AndroidRuntime.start函数 runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote); &#125; else if (className) &#123; runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote); &#125; else &#123; ... &#125;&#125; 我们进一步来看AndroidRuntime的start流程代码： AndroidRuntime源码 1234567891011121314151617181920212223242526272829303132333435363738/*frameworks/base/core/jni/AndroidRuntime.cpp*/void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123; ... /* start the virtual machine */ JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; if (startVm(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != 0) &#123; // 1.启动VM虚拟机 return; &#125; onVmCreated(env); /* * Register android functions. */ if (startReg(env) &lt; 0) &#123; // 2.注册框架JNI调用到虚拟机中 ALOGE(&quot;Unable to register all android natives &quot;); return; &#125; ... char* slashClassName = toSlashClassName(className != NULL ? className : &quot;&quot;); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) &#123; ALOGE(&quot;JavaVM unable to locate class &#x27;%s&#x27; &quot;, slashClassName); &#125; else &#123; // 3.JNI调用进入java层执行ZygoteInit的main函数 jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;); if (startMeth == NULL) &#123; ALOGE(&quot;JavaVM unable to find main() in &#x27;%s&#x27; &quot;, className); /* keep going */ &#125; else &#123; env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); ... &#125; ...&#125; 从代码中可以看到AndroidRuntime#start方法中主要完成三件事情： 启动进程的VM虚拟机； 注册Android系统框架JNI调用到虚拟机中； 通过JNI调用进入java层执行ZygoteInit的main函数； 1234AI通义回答：Q：android 系统启动时 app_process是运行在哪个进程中A:当app_process被执行时，它实际上是在一个新的进程中运行。这个新进程就是Zygote进程。在Zygote启动的过程中，app_process会根据传递给它的参数来决定其行为。例如，如果带有--zygote标志，那么app_process就会初始化Zygote并开始监听socket连接，等待Activity Manager Service (AMS) 发起的请求以创建新的应用进程。因此，可以明确地说，在Android系统启动过程中，app_process是运行在Zygote进程中。 3.3.2 java层：ZyogeInit由3.3.1调用执行java层ZygoteInit的main函数 ZyogeInit.java源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/*frameworks/base/core/java/com/android/internal/os/ZygoteInit.java*/ public static void main(String[] argv) &#123; ZygoteServer zygoteServer = null; ... try &#123; ... for (int i = 1; i &lt; argv.length; i++) &#123; // 在init.rc文件中，有--start-system-server参数，表示要创建SystemServer if (&quot;start-system-server&quot;.equals(argv[i])) &#123; startSystemServer = true; &#125; else if (&quot;--enable-lazy-preload&quot;.equals(argv[i])) &#123; enableLazyPreload = true; &#125; &#125; ... if (!enableLazyPreload) &#123; ... preload(bootTimingsTraceLog); // 1.预加载资源 ... &#125; ... zygoteServer = new ZygoteServer(isPrimaryZygote); // 2.创建Socket服务端 if (startSystemServer) &#123; Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer); // 3.fork启动system_server进程 ... &#125; ... //4. sokcet服务端等待AMS请求（AMS会通过socket请求Zygote来创建应用程序进程） caller = zygoteServer.runSelectLoop(abiList); &#125; catch (Throwable ex) &#123; Log.e(TAG, &quot;System zygote died with fatal exception&quot;, ex); throw ex; &#125; finally &#123; if (zygoteServer != null) &#123; zygoteServer.closeServerSocket(); &#125; &#125; // We&#x27;re in the child process and have exited the select loop. Proceed to execute the // command. if (caller != null) &#123; caller.run(); &#125; &#125; static void preload(TimingsTraceLog bootTimingsTraceLog) &#123; beginPreload(); preloadClasses(); // 1.预加载system/etc/preloaded-classes文件中定义的各个系统类 ... preloadResources(); // 2.预加载系统中定义的各个drawables、color资源 ... nativePreloadAppProcessHALs(); // 3.预加载某些硬件抽象层（HAL）模块 ... maybePreloadGraphicsDriver(); // 4.预加载图形驱动程序 ... preloadSharedLibraries(); // 5.预加载一些共享库（shared libraries） preloadTextResources(); //6.预加载一些常用的文本资源，如字体、字符串 WebViewFactory.prepareWebViewInZygote(); endPreload(); sPreloadComplete = true; &#125; 从代码中可以看到ZygoteInit#main方法中主要fork启动system_server进程： zygote进程中预加载类、主题资源、字体资源等 创建socket服务端，用于跨进程通信； fork创建启动系统system_server进程； Sokcet服务端进入循环监听等待，等待后续AMS请求（AMS会通过socket请求Zygote来创建应用程序进程）。 3.3.3 system_server进程的启动继续分析forkSystemServer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*frameworks/base/core/java/com/android/internal/os/ZygoteInit.java*/ private static Runnable forkSystemServer(String abiList, String socketName, ZygoteServer zygoteServer) &#123; ... int pid; try &#123; ... /* Request to fork the system server process */ // 1.fork创建system_server进程 pid = Zygote.forkSystemServer( parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids, parsedArgs.mRuntimeFlags, null, parsedArgs.mPermittedCapabilities, parsedArgs.mEffectiveCapabilities); &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; /* For child process */ if (pid == 0) &#123; if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; // 2.pid为0代表在新创建的system_server进程中，继续通过handleSystemServerProcess进一步处理 zygoteServer.closeServerSocket(); return handleSystemServerProcess(parsedArgs); &#125; return null; &#125; private static Runnable handleSystemServerProcess(ZygoteArguments parsedArgs) &#123; ... &#125; else &#123; return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion, parsedArgs.mDisabledCompatChanges, parsedArgs.mRemainingArgs, cl); &#125; &#125; public static Runnable zygoteInit(int targetSdkVersion, long[] disabledCompatChanges, String[] argv, ClassLoader classLoader) &#123; ... RuntimeInit.commonInit(); // 1.触发启动进程的Binder线程池 ZygoteInit.nativeZygoteInit(); // 2.通过反射创建&quot;com.android.server.SystemServer&quot;类对象并执行其main函数 return RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv, classLoader); &#125; ZygoteInit.nativeZygoteInit()：触发进程Binder线程池，后续Binder再分析。 RuntimeInit.applicationInit()：反射方式执行SystemServer的main函数 接下来是SystemServer启动的main方法 12345678910111213141516171819202122232425262728293031323334353637/*frameworks/base/services/java/com/android/server/SystemServer.java*/public static void main(String[] args) &#123; new SystemServer().run();&#125;private void run() &#123; ... // 1.创建主线程Looper Looper.prepareMainLooper(); // 2.创建系统Context上下文 createSystemContext(); // 3.创建SystemServiceManager，用于后续系统服务（AMS、WMS等）的创建、启动和生命周期管理 mSystemServiceManager = new SystemServiceManager(mSystemContext); mSystemServiceManager.setStartInfo(mRuntimeRestart, mRuntimeStartElapsedTime, mRuntimeStartUptime); LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); // 4.服务根据优先级被分成3批来启动： try &#123; t.traceBegin(&quot;StartServices&quot;); //启动引导服务 startBootstrapServices(t); //启动核心服务 startCoreServices(t); //启动其他服务 startOtherServices(t); //启动 APEX 服务 startApexServices(t); &#125; catch (Throwable ex) &#123; Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex); throw ex; &#125; finally &#123; t.traceEnd(); // StartServices &#125; // 5.开启looper循环 Looper.loop();&#125; 3.4 System Server启动的主要服务以下为System Server启动的主要服务列表，具体实现可在源码中查看。 服务名称 功能说明 Activity Manager Service (AMS) 管理应用程序的生命周期，包括启动和停止应用、管理任务和活动栈、处理广播等 Package Manager Service (PMS) 管理应用包的安装、卸载、更新、权限分配等 System Config Service 管理系统配置和资源 Power Manager Service 管理设备的电源状态和电源策略，如休眠、唤醒等 Display Manager Service 管理显示设备，如屏幕亮度、显示模式等 User Manager Service 管理用户账户和用户信息 Battery Service 监控和管理电池状态和电池使用情况 Vibrator Service 控制设备的振动功能 Sensor Service 管理设备的传感器，如加速度计、陀螺仪等 Window Manager Service (WMS) 管理窗口和显示内容，包括窗口的创建、删除、布局等 Input Manager Service 管理输入设备，如触摸屏、键盘等 Alarm Manager Service 提供定时任务调度功能 Connectivity Service 管理网络连接，如 Wi-Fi、移动数据等 Network Management Service 管理网络接口和网络连接 Telephony Registry 管理电话和短信服务 Input Method Manager Service (IMMS) 管理输入法框架 Accessibility Manager Service 管理无障碍服务，为有特殊需要的用户提供辅助功能 Mount Service 管理存储设备的挂载和卸载 Location Manager Service 管理位置服务，如 GPS 和网络定位 Search Manager Service 管理系统搜索功能 Clipboard Service 管理剪贴板功能 DevicePolicy Manager Service 管理设备的安全策略和企业管理功能 Status Bar Service 管理状态栏显示和操作 Wallpaper Manager Service 管理壁纸设置和操作 Media Router Service 管理媒体设备路由 四、总结Android系统启动的核心流程如下： Linux内核启动 init进程启动 init进程fork出Zygote进程 Zygote进程fork出SystemServer进程 SystemServer进程启动各项服务（PMS、AMS等） AMS服务启动Launcher桌面 参考文章： Android系统启动流程（基于Android 11） Android启动过程-万字长文(Android14) http://gityuan.com/android/ TODO： 可执行文件，与Zygote是同一个进程中吗？要不然，怎么执行相应的文件 可执行文件与进程的区别","tags":["Android","framework"],"categories":["Android"]}]