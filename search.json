[{"title":"C++双冒号::的作用","path":"/2024/09/27/C双冒号的作用/","content":"全局命名空间全局命名空间是一个包含所有全局变量、函数和类型的隐式命名空间。如果想要在一个局部作用域内访问全局作用域的实体，可以使用双冒号::。 123456789101112#include &lt;iostream&gt;int var = 10; // global variableint main() &#123; int var = 20; // local variable std::cout &lt;&lt; &quot;Global var: &quot; &lt;&lt; ::var &lt;&lt; std::endl; // 全局参数var std::cout &lt;&lt; &quot;Local var: &quot; &lt;&lt; var &lt;&lt; std::endl; // 局部参数var return 0;&#125; 1234567char zhou; //全局变量 void sleep（） ｛ char zhou; //局部变量 char(局部变量) = char(局部变量) *char(局部变量) ; ::char(全局变量) =::char(全局变量) *char(局部变量); ｝ 上述代码中，全局变量和局部变量同名。通过::运算符，我们可以明确地引用全局变量。 &nbsp; 类成员访问在C++中，双冒号::也用于访问类的静态成员。 123456789101112131415161718class MyClass &#123;public: static int static_var; static void static_function() &#123; std::cout &lt;&lt; &quot;Static function&quot; &lt;&lt; std::endl; &#125;&#125;;int MyClass::static_var = 10; // define static member outside the classint main() &#123; std::cout &lt;&lt; &quot;Static var: &quot; &lt;&lt; MyClass::static_var &lt;&lt; std::endl; MyClass::static_function(); return 0;&#125; 在上述代码中，::被用来访问类的静态成员。注意静态成员需要在类外部定义。 &nbsp; 命名空间访问双冒号::还被用于明确指定某个命名空间中的实体。 123456789101112131415namespace MyNamespace &#123; int var = 10; void function() &#123; std::cout &lt;&lt; &quot;Function in namespace&quot; &lt;&lt; std::endl; &#125;&#125;&lt;span style=&quot;color: #7f7f7f&quot;&gt;指定某个命名空间中的实体&lt;/span&gt;int main() &#123; std::cout &lt;&lt; &quot;Var: &quot; &lt;&lt; MyNamespace::var &lt;&lt; std::endl; MyNamespace::function(); return 0;&#125; 在上述代码中，::被用来访问特定命名空间中的变量和函数。 &nbsp; 解决名称冲突.双冒号::还可以用于解决名称冲突，例如当使用了相同名称的两个库时。 123456789101112131415namespace Library1 &#123; void print() &#123; std::cout &lt;&lt; &quot;Print from Library1&quot; &lt;&lt; std::endl; &#125;&#125;namespace Library2 &#123; void print() &#123; std::cout &lt;&lt; &quot;Print from Library2&quot; &lt;&lt; std::endl; &#125;&#125;int main() &#123; Library1::print(); Library2::print(); return 0;&#125; 类方法定义前面一般是类名称，后面一般是该类的成员名称，C++为例避免不同的类有名称相同的成员而采用作用域的方式进行区分如：A,B表示两个类，在A,B中都有成员member。那么A::member就表示类A中的成员memberB::member就表示类B中的成员member 比如声明了一个类A，类A里声明了一个成员函数voidf()，但没有在类的声明里给出f的定义，那么在类外定义f时，就要写成voidA::f()，表示这个f()函数是类A的成员函数。例如 1234567891011121314151617181920class CA &#123; public: int ca_var; int add(int a, int b); int add(int a); &#125;; //那么在实现这个函数时，必须这样书写： int CA::add(int a, int b) &#123; return a + b; &#125; //另外，双冒号也常常用于在类变量内部作为当前类实例的元素进行表示，比如: int CA::add(int a) &#123; return a + ::ca_var; &#125; //表示当前类实例中的变量ca_var。 模板类中的双冒号在模板类中，双冒号用于访问基础模板类的成员。 123456789101112131415161718192021222324template&lt;class T&gt;class MyClass &#123;public: T var; MyClass(T x) &#123; this-&gt;var = x; &#125;&#125;;template&lt;&gt;class MyClass&lt;int&gt; &#123;public: int var; MyClass(int x) &#123; this-&gt;var = x; &#125; void print_base_var(MyClass&lt;double&gt;&amp; base_obj) &#123; std::cout &lt;&lt; &quot;Base var: &quot; &lt;&lt; base_obj.MyClass&lt;double&gt;::var &lt;&lt; std::endl; &#125;&#125;; 在上述代码中，特化的模板类MyClass&lt;int&gt;使用::来访问基础模板类MyClass&lt;double&gt;的成员。 &nbsp;","tags":["C/C++基础"],"categories":["C/C++"]},{"title":"Binder原理浅析","path":"/2024/09/27/Binder原理浅析/","content":"Binder原理浅析一、Binder优势 优势 描述 性能 一次数据拷贝，mmap内存映射 稳定性 基于 C&#x2F;S 架构，架构清晰、职责明确 安全性 为每个APP分配UID，鉴别进程身份的重要标志，阻止恶意程序通过猜测接收方地址获得连接 二、Binder概要设计2.1、进程隔离 操作系统中，进程与进程间内存是不共享的。两个进程就像两个平行的世界，A 进程没法直接访问 B 进程的数据，这就是进程隔离的通俗解释。A 进程和 B 进程之间要进行数据交互就得采用特殊的通信机制：进程间通信（IPC）。 .jgbgrxqwssew{zoom:50%;} 操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。为了保证安全性，它们之间是隔离的，用户空间需要经过系统调用才能访问到内核空间。 2.2、Binder通信模型Binder由四个组件Client、Server、Service Manager和Binder驱动程序组成 Client、Server和Service Manager实现在用户空间中，Binder驱动程序实现在内核空间中 Binder驱动程序和Service Manager在Android平台中已经实现，开发者只需要在用户空间实现自己的Client和Server Binder驱动程序提供设备文件&#x2F;dev&#x2F;binder与用户空间交互，Client、Server和Service Manager通过open和ioctl文件操作函数与Binder驱动程序进行通信 Client和Server之间的进程间通信通过Binder驱动程序间接实现 Service Manager是一个守护进程，用来管理Server，并向Client提供查询Server接口的能力 2.3、Binder通信过程 首先，一个进程使用 BINDER_SET_CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager； Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。 Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。 我们看到整个通信过程都需要 Binder 驱动的接入。下图能更加直观的展现整个通信过程(为了进一步抽象通信过程以及呈现上的方便，下图我们忽略了 Binder 实体及其引用的概念)： 2.4、Binder实现过程2.4.1、 实现图解client请求service服务，比如说Activity请求Activity ManagerService服务，由于Activity和ActivityManagerService是在两个不同的进程中的，那么下图是一个很直观的请求过程。 但是注意，一个进程是不能直接直接操作另一个进程的，比如说读取另一个进程的数据，或者往另一个进程的内存空间写数据，进程之间的通信要通过内核进程才可以，因此这里就要使用到进程通信工具Binder了如下图： 但是上面还有个问题就是client和service要直接和binder driver打交道，但是实际上client和service并不想知道binder相关协议，所以进一步client通过添加proxy代理，service通过添加stub来进一步处理与binder的交互。 这样的好处是client和service都可以不用直接去和binder打交道。上面的图好像已经很完善了，但是Android系统更进一步封装，不让client知道Binder的存在，Android系统提供了Manager来管理client。如下图： 这样client只需要交给manager来管理就好了，根本就不用关心进程通信相关的事，关于manager其实是很熟悉的，比如说activity的就是由ActivityManager来控制的，ActivityManager是通过Binder获取ActivityManagerService来控制activity的。这样就不用我们自己来使用Binder来ActivityManagerService通信了。 更进一步，client是如何具体获取到哪个service的呢？如下图所示： 在service和binder之间还有一个contextManager，也就是serviceManager，每一个service要先往serviceManager里面进行注册，注册完成之后由serviceManager统一管理。 在Android studio中可以通过adb指定打印出当前已经注册过serviceManager的service。 2.4.2、实现示例示例调用流程如下： 2.4.2.1 客户端Activity1234567891011121314151617181920212223242526272829303132333435//NoAidlActivity.javaprotected void onCreate(Bundle savedInstanceState) &#123; Intent intent = new Intent(this, MyService.class); bindService(intent, new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; //1. 从对象池拿到可复用的对象（享元模式） Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); Log.e(&quot;哈利迪&quot;, &quot;--- 我是客户端 NoAidlActivity , pid = &quot; + Process.myPid() + &quot;, thread = &quot; + Thread.currentThread().getName()); String str = &quot;666&quot;; Log.e(&quot;哈利迪&quot;, &quot;客户端向服务端发送：&quot; + str); //2. 往data写数据，作为请求参数 data.writeString(str); //3. 拿到服务端的IBinder句柄，调用transact //约定行为码是1；需要服务端的返回值，所以flags传0表示同步调用 service.transact(1, data, reply, 0); Log.e(&quot;哈利迪&quot;, &quot;--- 我是客户端 NoAidlActivity , pid = &quot; + Process.myPid() + &quot;, thread = &quot; + Thread.currentThread().getName()); //4. 从reply读取服务端的返回值 Log.e(&quot;哈利迪&quot;, &quot;客户端接收服务端返回：&quot; + reply.readString()); &#125; &#125;, Context.BIND_AUTO_CREATE);&#125; 如上代码，主要查看步骤2与步骤3。写入参数’666’至data，service.transact把data作为参数传递。 2.4.2.2 服务端运行的Service12345678class MyService extends Service &#123; @Override public IBinder onBind(Intent intent) &#123; //返回服务端的IBinder句柄 return new MyBinder(); &#125;&#125; 注册服务，让服务端Service运行在:remote进程，来实现跨进程 123&lt;service android:name=&quot;.binder.no_aidl.MyService&quot; android:process=&quot;:remote&quot; /&gt; 运行在服务端的Binder对象 12345678910111213141516171819202122class MyBinder extends Binder &#123; @Override protected boolean onTransact(int code, Parcel data, Parcel reply, int flags)&#123; if (code == 1) &#123;//如果是约定好的行为码1 Log.e(&quot;哈利迪&quot;, &quot;--- 我是服务端 MyBinder , pid = &quot; + Process.myPid() + &quot;, thread = &quot; + Thread.currentThread().getName()); //1. 从data读取客户端参数 Log.e(&quot;哈利迪&quot;, &quot;服务端收到：&quot; + data.readString()); String str = &quot;777&quot;; Log.e(&quot;哈利迪&quot;, &quot;服务端返回：&quot; + str); //2. 从reply向客户端写返回值 reply.writeString(str); //3. 处理完成 return true; &#125; return super.onTransact(code, data, reply, flags); &#125;&#125; 输出日志 Binder机制使用了Parcel来序列化数据，客户端在主线程调用了transact来请求（Parcel data传参），服务端在Binder线程调用onTransact来响应（Parcel reply回传结果）。 三、Binder源码流程3.1、Binder的调用流程图 3.2、客户端与驱动交互先来看客户端与驱动的交互。因为是跨进程调用（指定了:remote），示例里onServiceConnected回调回来的service对象是个BinderProxy代理实例（不跨进程的话会发生远程转本地，后面讲），我们以service.transact(1, data, reply, 0)这行调用作为入口跟进。 123456//BinderProxy.javapublic boolean transact(int code, Parcel data, Parcel reply, int flags)&#123; //调用了native方法 return transactNative(code, data, reply, flags);&#125; 这个native方法在android_util_Binder.cpp里注册 123456789101112131415161718192021//android_util_Binder.cpp//JNI注册static const JNINativeMethod gBinderProxyMethods[] = &#123; &#123; &quot;transactNative&quot;, &quot;(ILandroid/os/Parcel;Landroid/os/Parcel;I)Z&quot;, (void*)android_os_BinderProxy_transact&#125;,&#125;;//native方法具体实现static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj, jint code, jobject dataObj, jobject replyObj, jint flags)&#123; //转成native层的Parcel Parcel* data = parcelForJavaObject(env, dataObj); Parcel* reply = parcelForJavaObject(env, replyObj); //拿到native层的句柄BpBinder IBinder* target = (IBinder*) env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject); //调用BpBinder的transact status_t err = target-&gt;transact(code, *data, reply, flags);&#125; 继续跟BpBinder.cpp 1234567//BpBinder.cppstatus_t BpBinder::transact(...)&#123; //交给线程单例处理，驱动会根据mHandle值来找到对应的binder句柄 status_t status = IPCThreadState::self()-&gt;transact( mHandle, code, data, reply, flags);&#125; IPCThreadState是一个线程单例，负责与binder驱动进行具体的指令通信，跟进IPCThreadState.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//IPCThreadState.cppstatus_t IPCThreadState::transact(...)&#123; //将数据写入mOut，见1.1 err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL); //...先忽略one way异步调用的代码，只看有返回值的同步调用 //跟binder驱动交互，传入reply接收返回数据，见1.2 err = waitForResponse(reply);&#125;//1.1 将数据写入mOutstatus_t IPCThreadState::writeTransactionData(...)&#123; binder_transaction_data tr; //...打包各种数据（data size、buffer、offsets） tr.sender_euid = 0; //将BC_TRANSACTION指令写入mOut mOut.writeInt32(cmd); //将打包好的binder_transaction_data写入mOut mOut.write(&amp;tr, sizeof(tr));&#125;//1.2 跟binder驱动交互，传入reply接收返回数据status_t IPCThreadState::waitForResponse(...)&#123; //这个循环很重要，客户端就是在这里休眠等待服务端返回结果的 while (1) &#123; //跟驱动进行数据交互，往驱动写mOut，从驱动读mIn，见1.3 talkWithDriver(); //读取驱动回复的指令 cmd = (uint32_t)mIn.readInt32(); switch (cmd) &#123; case BR_TRANSACTION_COMPLETE: //表示驱动已经收到客户端的transact请求 //如果是one way异步调用，到这就可以结束了 if (!reply &amp;&amp; !acquireResult) goto finish; break; case BR_REPLY: //表示客户端收到服务端的返回结果 binder_transaction_data tr; //把服务端的数据读出来，打包进tr err = mIn.read(&amp;tr, sizeof(tr)); //再把tr的数据透传进reply reply-&gt;ipcSetDataReference(...); //结束 goto finish; &#125; &#125;&#125;//1.3 跟驱动进行数据交互，往驱动写mOut，从驱动读mInstatus_t IPCThreadState::talkWithDriver(bool doReceive)&#123; binder_write_read bwr; //指定写数据大小和写缓冲区 bwr.write_size = outAvail; bwr.write_buffer = (uintptr_t)mOut.data(); //指定读数据大小和读缓冲区 if (doReceive &amp;&amp; needRead) &#123; bwr.read_size = mIn.dataCapacity(); bwr.read_buffer = (uintptr_t)mIn.data(); &#125; else &#123; bwr.read_size = 0; bwr.read_buffer = 0; &#125; //ioctl的调用进入了binder驱动层的binder_ioctl ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr); if (bwr.write_consumed &gt; 0) &#123; //数据已经写入驱动，从mOut移除 if (bwr.write_consumed &lt; mOut.dataSize()) mOut.remove(0, bwr.write_consumed); else mOut.setDataSize(0); &#125; if (bwr.read_consumed &gt; 0) &#123; //从驱动读出数据存入mIn mIn.setDataSize(bwr.read_consumed); mIn.setDataPosition(0); &#125;&#125; ioctl的调用进入了binder驱动层的binder_ioctl 3.3、服务端与驱动交互服务端创建了一个线程注册进binder驱动，即binder线程，在ProcessState.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//IPCThreadState.cppvoid IPCThreadState::joinThreadPool(bool isMain)&#123; //向binder驱动写数据，表示当前线程需要注册进binder驱动 mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER); status_t result; do &#123; //进入死循环，等待指令的到来，见1.1 result = getAndExecuteCommand(); &#125; while (result != -ECONNREFUSED &amp;&amp; result != -EBADF); //向binder驱动写数据（退出循环，线程结束） mOut.writeInt32(BC_EXIT_LOOPER);&#125;//1.1 等待指令的到来status_t IPCThreadState::getAndExecuteCommand()&#123; //跟驱动进行数据交互，驱动会把指令写进mIn talkWithDriver(); //从mIn读出指令 cmd = mIn.readInt32(); //执行指令，见1.2 result = executeCommand(cmd); return result;&#125;//1.2 执行指令status_t IPCThreadState::executeCommand(int32_t cmd)&#123; //客户端发请求到驱动，驱动转发到服务端 switch ((uint32_t)cmd) &#123; case BR_TRANSACTION:&#123; //服务端收到BR_TRANSACTION指令 binder_transaction_data tr; //读出客户端请求的参数 result = mIn.read(&amp;tr, sizeof(tr)); //准备数据，向上传给Java层 Parcel buffer; Parcel reply; buffer.ipcSetDataReference(...); //cookie保存的是binder实体，对应服务端的native层对象就是BBinder reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, buffer, &amp;reply, tr.flags); //服务端向驱动写返回值，让驱动转发给客户端 sendReply(reply, 0); &#125; &#125;&#125;//1.3 服务端向驱动写返回值，让驱动转发给客户端status_t IPCThreadState::sendReply(const Parcel&amp; reply, uint32_t flags)&#123; err = writeTransactionData(BC_REPLY, flags, -1, 0, reply, &amp;statusBuffer); //服务端返回结果给客户端就行，不用等待客户端，所以传NULL return waitForResponse(NULL, NULL);&#125; 然后看下BBinder的transact是怎么向上传递到Java层的，在Binder.cpp中 123456789101112131415161718192021222324//Binder.cppstatus_t BBinder::transact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; switch (code) &#123; //ping指令用来判断连通性，即binder句柄是否还活着 case PING_TRANSACTION: reply-&gt;writeInt32(pingBinder()); break; default: //看这，通过JNI调用到Java层的execTransact，见1.1 err = onTransact(code, data, reply, flags); break; &#125; return err;&#125;//android_util_Binder.cpp//1.1 通过JNI调用到Java层的execTransactvirtual status_t onTransact(...)&#123; JNIEnv* env = javavm_to_jnienv(mVM); jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact, ...);&#125; 回到Java层，execTransact如下： 12345//android.os.Binder.javaprivate boolean execTransact(...) &#123; res = onTransact(code, data, reply, flags);&#125; 额外Binder问题 1、[007]一次Binder通信最大可以传输多大的数据？ 2、Android跨进程传大图思考及实现——附上原理分析 1.Binder驱动给每个进程最多分配4M的buffer空间大小；2.异步事务的空闲缓冲区空间大小最多为2M；3.Binder内核内存上限为1M-8k;4.异步事务缓冲区空间大小等于buffer_size&#x2F;2，具体值取决于buffer_size; TODO：Binder内核、IPCThreadState相关知识点的整理 参考资料： Android Binder 线程 写给 Android 应用工程师的 Binder 原理剖析 图解 | 不得错过的Binder浅析（一） 图解Android中的binder机制 红茶一杯话 Binder（ServiceManager 篇） Android进程间通信（IPC）机制Binder简要介绍和学习计划（罗升阳）","tags":["Android","framework"],"categories":["Android"]},{"title":"Android启动流程","path":"/2024/09/26/Android启动流程/","content":"Android启动流程Android源码基于14 一、Android架构 二、启动流程 Boot ROM：用于加载并执行Boot Loader。Android 设备上电后，开始执行固化在 CPU芯片里的 Boot ROM 中的预设代码，程序将 Boot Loader 代码加载到 ROM 中。这一步由芯片厂商负责设计和实现。 Boot Loader：用于将系统代码加载到 RAM 中。具体功能有：检查 RAM、初始化系统的硬件参数等功能，找到 Linux kernel 的代码，设置启动参数，并最终加载到RAM中。 Kernel：Linux 内核开始启动，初始化各种软硬件环境、加载驱动程序、挂载根文件系统、并执行 init 程序，由此开启 Android 的世界。 Init：内核初始化完成后，会启动名为init的用户空间进程。init进程是Android系统的第一个用户空间进程，它负责系统的进一步初始化和启动。init进程会读取系统配置文件（例如 init.rc），并根据其中的指令启动系统服务和应用程序。 12345init进程会孵化出ueventd、logd、healthd、installd、adbd、lmkd等用户守护进程；init进程还启动servicemanager(binder服务管家)、bootanim(开机动画)等重要服务init进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程(即虚拟机进程)，Zygote是所有Java进程的父进程，Zygote进程本身是由init进程孵化而来的。 Zygote：Zygote 是 Android 系统的启动进程，Zygote 会启动 System Servers。 System Servers：是Android系统的核心，负责启动和管理整个Java FrameWork，包含ActivityManagerService， WorkManagerService，PagerManagerService，PowerManagerService等服务。 三、Zygote进程(孵化器进程)init进程通过解析init.rc文件来启动各种服务和进程，包括Zygote 3.1 init.rc脚本解析init.rc源码地址 1234567891011121314151617/*system/core/rootdir/init.rc*/import /system/etc/init/hw/init.$&#123;ro.zygote&#125;.rc...on late-init # Now we can start zygote for devices with file based encryption trigger zygote-start // 1. 触发启动zygote...on zygote-start &amp;&amp; property:ro.crypto.state=encrypted &amp;&amp; property:ro.crypto.type=file wait_for_prop odsign.verification.done 1 # A/B update verifier that marks a successful boot. exec_start update_verifier_nonencrypted start statsd start netd start zygote // 2.启动zygote服务 start zygote_secondary... $&#123;ro.zygote&#125;的取值有4种，在init.rc的同级目录system&#x2F;core&#x2F;rootdir&#x2F;下，现在普遍使用的是init.zygote64_32.rc 12345678910111213141516171819202122232425# service zygote: 定义一个名为zygote的服务# /system/bin/app_process64： 这是启动Zygote进程的可执行文件# --start-system-server：Zygote进程启动后需要启动system_server进程，ZygoteInit.java会对参数进行处理service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote class main priority -20 user root group root readproc reserved_disk socket zygote stream 660 root system # 创建一个名为zygote的socket，用于其他进程与Zygote进程通信。 socket usap_pool_primary stream 660 root system onrestart exec_background - system system -- /system/bin/vdc volume abort_fuse onrestart write /sys/power/state on # NOTE: If the wakelock name here is changed, then also # update it in SystemSuspend.cpp #当zygote服务重启时，系统应重启的功能 onrestart write /sys/power/wake_lock zygote_kwl onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart media.tuner onrestart restart netd onrestart restart wificond task_profiles ProcessCapacityHigh MaxPerformance critical window=$&#123;zygote.critical_window.minute:-off&#125; target=zygote-fatal 3.2 启动Zygote进程init进程启动后，通过fork和execv来启动Zygote进程，如下简化代码所示： service.cpp源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354static bool ExpandArgsAndExecv(const std::vector&lt;std::string&gt;&amp; args, bool sigstop) &#123; std::vector&lt;std::string&gt; expanded_args; std::vector&lt;char*&gt; c_strings; expanded_args.resize(args.size()); c_strings.push_back(const_cast&lt;char*&gt;(args[0].data())); for (std::size_t i = 1; i &lt; args.size(); ++i) &#123; auto expanded_arg = ExpandProps(args[i]); if (!expanded_arg.ok()) &#123; LOG(FATAL) &lt;&lt; args[0] &lt;&lt; &quot;: cannot expand arguments&#x27;: &quot; &lt;&lt; expanded_arg.error(); &#125; expanded_args[i] = *expanded_arg; c_strings.push_back(expanded_args[i].data()); &#125; c_strings.push_back(nullptr); if (sigstop) &#123; kill(getpid(), SIGSTOP); &#125;\t// 2. c_strings[0]是执行程序路径，即如果启动的是zygote服务时，execve会运行/system/bin/app_process64 return execv(c_strings[0], c_strings.data()) == 0;&#125;void Service::RunService(const std::vector&lt;Descriptor&gt;&amp; descriptors, InterprocessFifo cgroups_activated, InterprocessFifo setsid_finished) &#123;\t... if (!ExpandArgsAndExecv(args_, sigstop_)) &#123; PLOG(ERROR) &lt;&lt; &quot;cannot execv(&#x27;&quot; &lt;&lt; args_[0] &lt;&lt; &quot;&#x27;). See the &#x27;Debugging init&#x27; section of init&#x27;s README.md for tips&quot;; &#125;&#125;Result&lt;void&gt; Service::Start() &#123;\t... pid_t pid = -1; if (namespaces_.flags) &#123; pid = clone(nullptr, nullptr, namespaces_.flags | SIGCHLD, nullptr); &#125; else &#123; pid = fork(); // 1.fork创建service进程（也就是zygote进程） &#125; if (pid == 0) &#123; umask(077); cgroups_activated.CloseWriteFd(); setsid_finished.CloseReadFd(); RunService(descriptors, std::move(cgroups_activated), std::move(setsid_finished)); _exit(127); &#125; else &#123; cgroups_activated.CloseReadFd(); setsid_finished.CloseWriteFd(); &#125;\t...&#125; 3.3 zygote进程3.3.1 native层：app_process启动zygote.main&#x2F;system&#x2F;bin&#x2F;app_process是Android中的一个关键可执行文件，负责启动Zygote进程和应用进程。 app_process源码地址 12345678910111213141516171819202122232425262728293031/*frameworks/base/cmds/app_process/app_main.cpp*/int main(int argc, char* const argv[])&#123; ... // Parse runtime arguments. Stop at first unrecognized option. bool zygote = false; ... while (i &lt; argc) &#123; const char* arg = argv[i++]; if (strcmp(arg, &quot;--zygote&quot;) == 0) &#123; zygote = true; // 参数标识启动zygote进程 niceName = ZYGOTE_NICE_NAME; &#125; else if (strcmp(arg, &quot;--start-system-server&quot;) == 0) &#123; startSystemServer = true; //参数标识启动system_server进程 &#125; ... &#125; ... if (!niceName.isEmpty()) &#123; runtime.setArgv0(niceName.string(), true /* setProcName */); // 进程名app_process修改为zygote &#125; if (zygote) &#123; // 启动Zygote，执行AndroidRuntime.start函数 runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote); &#125; else if (className) &#123; runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote); &#125; else &#123; ... &#125;&#125; 我们进一步来看AndroidRuntime的start流程代码： AndroidRuntime源码 1234567891011121314151617181920212223242526272829303132333435363738/*frameworks/base/core/jni/AndroidRuntime.cpp*/void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123; ... /* start the virtual machine */ JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; if (startVm(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != 0) &#123; // 1.启动VM虚拟机 return; &#125; onVmCreated(env); /* * Register android functions. */ if (startReg(env) &lt; 0) &#123; // 2.注册框架JNI调用到虚拟机中 ALOGE(&quot;Unable to register all android natives &quot;); return; &#125; ... char* slashClassName = toSlashClassName(className != NULL ? className : &quot;&quot;); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) &#123; ALOGE(&quot;JavaVM unable to locate class &#x27;%s&#x27; &quot;, slashClassName); &#125; else &#123; // 3.JNI调用进入java层执行ZygoteInit的main函数 jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;); if (startMeth == NULL) &#123; ALOGE(&quot;JavaVM unable to find main() in &#x27;%s&#x27; &quot;, className); /* keep going */ &#125; else &#123; env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); ... &#125; ...&#125; 从代码中可以看到AndroidRuntime#start方法中主要完成三件事情： 启动进程的VM虚拟机； 注册Android系统框架JNI调用到虚拟机中； 通过JNI调用进入java层执行ZygoteInit的main函数； 1234AI通义回答：Q：android 系统启动时 app_process是运行在哪个进程中A:当app_process被执行时，它实际上是在一个新的进程中运行。这个新进程就是Zygote进程。在Zygote启动的过程中，app_process会根据传递给它的参数来决定其行为。例如，如果带有--zygote标志，那么app_process就会初始化Zygote并开始监听socket连接，等待Activity Manager Service (AMS) 发起的请求以创建新的应用进程。因此，可以明确地说，在Android系统启动过程中，app_process是运行在Zygote进程中。 3.3.2 java层：ZyogeInit由3.3.1调用执行java层ZygoteInit的main函数 ZyogeInit.java源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/*frameworks/base/core/java/com/android/internal/os/ZygoteInit.java*/ public static void main(String[] argv) &#123; ZygoteServer zygoteServer = null;\t... try &#123; ... for (int i = 1; i &lt; argv.length; i++) &#123; // 在init.rc文件中，有--start-system-server参数，表示要创建SystemServer if (&quot;start-system-server&quot;.equals(argv[i])) &#123; startSystemServer = true; &#125; else if (&quot;--enable-lazy-preload&quot;.equals(argv[i])) &#123; enableLazyPreload = true; &#125; &#125; ... if (!enableLazyPreload) &#123; ... preload(bootTimingsTraceLog); // 1.预加载资源 ... &#125; ... zygoteServer = new ZygoteServer(isPrimaryZygote); // 2.创建Socket服务端 if (startSystemServer) &#123; Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer); // 3.fork启动system_server进程 ... &#125; ... //4. sokcet服务端等待AMS请求（AMS会通过socket请求Zygote来创建应用程序进程） caller = zygoteServer.runSelectLoop(abiList); &#125; catch (Throwable ex) &#123; Log.e(TAG, &quot;System zygote died with fatal exception&quot;, ex); throw ex; &#125; finally &#123; if (zygoteServer != null) &#123; zygoteServer.closeServerSocket(); &#125; &#125; // We&#x27;re in the child process and have exited the select loop. Proceed to execute the // command. if (caller != null) &#123; caller.run(); &#125; &#125; static void preload(TimingsTraceLog bootTimingsTraceLog) &#123; beginPreload(); preloadClasses(); // 1.预加载system/etc/preloaded-classes文件中定义的各个系统类\t... preloadResources(); // 2.预加载系统中定义的各个drawables、color资源 ... nativePreloadAppProcessHALs(); // 3.预加载某些硬件抽象层（HAL）模块\t... maybePreloadGraphicsDriver(); // 4.预加载图形驱动程序\t... preloadSharedLibraries(); // 5.预加载一些共享库（shared libraries） preloadTextResources(); //6.预加载一些常用的文本资源，如字体、字符串 WebViewFactory.prepareWebViewInZygote(); endPreload(); sPreloadComplete = true; &#125; 从代码中可以看到ZygoteInit#main方法中主要fork启动system_server进程： zygote进程中预加载类、主题资源、字体资源等 创建socket服务端，用于跨进程通信； fork创建启动系统system_server进程； Sokcet服务端进入循环监听等待，等待后续AMS请求（AMS会通过socket请求Zygote来创建应用程序进程）。 3.3.3 system_server进程的启动继续分析forkSystemServer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*frameworks/base/core/java/com/android/internal/os/ZygoteInit.java*/ private static Runnable forkSystemServer(String abiList, String socketName, ZygoteServer zygoteServer) &#123; ... int pid; try &#123; ... /* Request to fork the system server process */ // 1.fork创建system_server进程 pid = Zygote.forkSystemServer( parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids, parsedArgs.mRuntimeFlags, null, parsedArgs.mPermittedCapabilities, parsedArgs.mEffectiveCapabilities); &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; /* For child process */ if (pid == 0) &#123; if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; // 2.pid为0代表在新创建的system_server进程中，继续通过handleSystemServerProcess进一步处理 zygoteServer.closeServerSocket(); return handleSystemServerProcess(parsedArgs); &#125; return null; &#125; private static Runnable handleSystemServerProcess(ZygoteArguments parsedArgs) &#123; ... &#125; else &#123; return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion, parsedArgs.mDisabledCompatChanges, parsedArgs.mRemainingArgs, cl); &#125; &#125; public static Runnable zygoteInit(int targetSdkVersion, long[] disabledCompatChanges, String[] argv, ClassLoader classLoader) &#123; ... RuntimeInit.commonInit(); // 1.触发启动进程的Binder线程池 ZygoteInit.nativeZygoteInit(); // 2.通过反射创建&quot;com.android.server.SystemServer&quot;类对象并执行其main函数 return RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv, classLoader); &#125; ZygoteInit.nativeZygoteInit()：触发进程Binder线程池，后续Binder再分析。 RuntimeInit.applicationInit()：反射方式执行SystemServer的main函数 接下来是SystemServer启动的main方法 12345678910111213141516171819202122232425262728293031323334353637/*frameworks/base/services/java/com/android/server/SystemServer.java*/public static void main(String[] args) &#123; new SystemServer().run();&#125;private void run() &#123; ... // 1.创建主线程Looper Looper.prepareMainLooper(); // 2.创建系统Context上下文 createSystemContext(); // 3.创建SystemServiceManager，用于后续系统服务（AMS、WMS等）的创建、启动和生命周期管理 mSystemServiceManager = new SystemServiceManager(mSystemContext); mSystemServiceManager.setStartInfo(mRuntimeRestart, mRuntimeStartElapsedTime, mRuntimeStartUptime); LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); // 4.服务根据优先级被分成3批来启动： try &#123; t.traceBegin(&quot;StartServices&quot;); //启动引导服务 startBootstrapServices(t); //启动核心服务 startCoreServices(t); //启动其他服务 startOtherServices(t); //启动 APEX 服务 startApexServices(t); &#125; catch (Throwable ex) &#123; Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex); throw ex; &#125; finally &#123; t.traceEnd(); // StartServices &#125; // 5.开启looper循环 Looper.loop();&#125; 3.4 System Server启动的主要服务以下为System Server启动的主要服务列表，具体实现可在源码中查看。 服务名称 功能说明 Activity Manager Service (AMS) 管理应用程序的生命周期，包括启动和停止应用、管理任务和活动栈、处理广播等 Package Manager Service (PMS) 管理应用包的安装、卸载、更新、权限分配等 System Config Service 管理系统配置和资源 Power Manager Service 管理设备的电源状态和电源策略，如休眠、唤醒等 Display Manager Service 管理显示设备，如屏幕亮度、显示模式等 User Manager Service 管理用户账户和用户信息 Battery Service 监控和管理电池状态和电池使用情况 Vibrator Service 控制设备的振动功能 Sensor Service 管理设备的传感器，如加速度计、陀螺仪等 Window Manager Service (WMS) 管理窗口和显示内容，包括窗口的创建、删除、布局等 Input Manager Service 管理输入设备，如触摸屏、键盘等 Alarm Manager Service 提供定时任务调度功能 Connectivity Service 管理网络连接，如 Wi-Fi、移动数据等 Network Management Service 管理网络接口和网络连接 Telephony Registry 管理电话和短信服务 Input Method Manager Service (IMMS) 管理输入法框架 Accessibility Manager Service 管理无障碍服务，为有特殊需要的用户提供辅助功能 Mount Service 管理存储设备的挂载和卸载 Location Manager Service 管理位置服务，如 GPS 和网络定位 Search Manager Service 管理系统搜索功能 Clipboard Service 管理剪贴板功能 DevicePolicy Manager Service 管理设备的安全策略和企业管理功能 Status Bar Service 管理状态栏显示和操作 Wallpaper Manager Service 管理壁纸设置和操作 Media Router Service 管理媒体设备路由 四、总结Android系统启动的核心流程如下： Linux内核启动 init进程启动 init进程fork出Zygote进程 Zygote进程fork出SystemServer进程 SystemServer进程启动各项服务（PMS、AMS等） AMS服务启动Launcher桌面 参考文章： Android系统启动流程（基于Android 11） Android启动过程-万字长文(Android14) http://gityuan.com/android/","tags":["Android","framework"],"categories":["Android"]}]