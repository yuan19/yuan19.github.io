[{"title":"技术点","path":"/2024/10/09/技术点/","content":"adb修改开者动画倍速12345adb shell settings put global window_animation_scale 10.0 &amp;&amp; adb shell settings put global transition_animation_scale 10.0 &amp;&amp; adb shell settings put global animator_duration_scale 10.0adb shell settings put global window_animation_scale 1.0 &amp;&amp; adb shell settings put global transition_animation_scale 1.0 &amp;&amp; adb shell settings put global animator_duration_scale 1.0adb shell settings get global window_animation_scale &amp;&amp; adb shell settings get global transition_animation_scale &amp;&amp; adb shell settings get global animator_duration_scale A14显示调试Debug进程1adb root &amp;&amp; adb remount &amp;&amp; adb shell setprop persist.debug.dalvik.vm.jdwp.enabled 1 &amp;&amp; adb reboot 源码 123456789#frameworks/base/core/java/com/android/internal/os/Zygote.javaprivate static final boolean ENABLE_JDWP = SystemProperties.get( &quot;persist.debug.dalvik.vm.jdwp.enabled&quot;).equals(&quot;1&quot;);static void applyDebuggerSystemProperty(ZygoteArguments args) &#123;\tif (Build.IS_ENG || ENABLE_JDWP) &#123; args.mRuntimeFlags |= Zygote.DEBUG_ENABLE_JDWP;\t&#125;&#125; Trace设置界面需先开启开发者模式 1adb shell am start com.android.traceur/com.android.traceur.MainActivity ninja设置1234ln -s prebuilts/build-tools/linux-x86/bin/ninja ninjaln -s out/combined-full_k61v1_64_bsp.ninja build.ninja./ninja framework-minus-apex -j32","tags":["Android","技术点"],"categories":["Android"]},{"title":"android日志相关","path":"/2024/10/08/android日志相关/","content":"android日志相关一、Log.isLoggable1protected static final boolean DEBUG_LOG = Log.isLoggable(&quot;CallController&quot;, Log.DEBUG); 1、机器重启后失效 1234adb shell setprop log.tag.CallController D#重新启动system_serveradb shell stopadb shell start 2、机器重启仍生效 添加persist关键字 1adb shell setprop persist.log.log.tag.CallController D 二、ProtoLog1ProtoLog.v(WM_DEBUG_ORIENTATION, &quot;Disabling listeners&quot;); ProtoLog是为WindowManager设计的，ProtoLog的命令也集成在内。 wm logging与cmd window logging，这两个指令等价。 ProtoLog有两种日志输出的方式： 1、winscope方式1.1、日志获取 名称&#x2F;命令 描述 wm logging enable&#x2F;disable [group…] 按照groups启停ProtoLog，真正启动是start命令，调用start命令之后才输出 wm logging start start proto logging 开始Proto log输出，让你enable的Group生效；输出到Logcat时不需要start wm logging stop stop proto logging 例如打开WM_DEBUG_ORIENTATION日志 12345678D:\\Program Files (x86)\\Mobatek\\home&gt; adb shellAEOP522:/ # wm logging enable WM_DEBUG_ORIENTATIONAEOP522:/ # wm logging startStart logging to /data/cache/wmtrace/wm_log.winscope.AEOP522:/ # wm logging stopStop logging to /data/cache/wmtrace/wm_log.winscope. Waiting for log to flush.Log written to /data/cache/wmtrace/wm_log.winscope. 1.2、日志分析得到winscope文件，adb pull &#x2F;data&#x2F;cache&#x2F;wmtrace&#x2F;wm_log.winscope，有两种方式解析分析 &#x2F;prebuilts&#x2F;misc&#x2F;common&#x2F;winscope&#x2F;运行用chrome运行winscope.html分析 利用protologtool分析 参考链接 Android动态日志ProtoLog简介和使用 android车机手机黑屏闪黑终结者-Winscope工具使用介绍 2、Logcat方式 名称&#x2F;命令 名称&#x2F;命令 wm logging enable-text&#x2F;disable-text [group…] 启停动态日志，输出到logcat，不需要调用start命令就会开始输出 例如打开WM_DEBUG_ORIENTATION日志 123adb shell wm logging enable-text WM_DEBUG_ORIENTATIONadb logcat -b all |grep -i WindowManager 三、LogBufferSystemUI有一个LogBuffer类，用于动态输出日志。 12345678910111213class NotificationInterruptLogger @Inject constructor( @NotificationInterruptLog val buffer: LogBuffer) &#123; fun logHeadsUp(entry: NotificationEntry) &#123; buffer.log(TAG, DEBUG, &#123; str1 = entry.logKey &#125;, &#123; &quot;Heads up: $str1&quot; &#125;) &#125;&#125;private const val TAG = &quot;InterruptionStateProvider&quot; 设置方式 1adb shell settings put global systemui/tag/InterruptionStateProvider v 四、Logcat123456789# 抓取普通的andorid logadb shell logcat &gt; log.txt# 仅抓取events logadb shell logcat -b events &gt; log.txt# 抓取所有类型logadb shell logcat -b all &gt; log.txt# 根据关键字抓取log，-i可以忽略大小，-e可以添加多条关键字，如下：adb shell logcat -b events | grep -ie &quot;关键log1&quot; -ie &quot;关键log2&quot;&gt; log.txt","tags":["Android","framework"],"categories":["Android"]},{"title":"又又又开户了","path":"/2024/10/07/又又又开户了/","content":"又又又开户了多年前的韭菜，现在又重新开户了，我胡汉三又回来了(^o^)&#x2F;","tags":["股票"],"categories":["生活杂谈"]},{"title":"广播日志分析","path":"/2024/09/30/广播日志分析/","content":"广播日志分析行 486404: S07E41A 05-29 14:13:04.516 965 965 V BroadcastQueue: Enqueuing BroadcastRecord{e6067ba android.intent.action.SCREEN_OFF&#x2F;u-1} from uid 1000 pid 965 for 57 receivers 这里的57 receivers代表是什么东西？ 这是Android操作系统中的一个日志条目，它描述了一个名为BroadcastRecord的对象的状态。下面是对这个日志条目的解释： Enqueuing: 这个词意味着一个事件被放入了队列中，等待处理。 BroadcastRecord: 这是一个Android中用于广播事件的类。当应用程序发送一个广播，系统会创建一个BroadcastRecord对象来处理这个广播。 &#123;e6067ba android.intent.action.SCREEN_OFF/u-1&#125;: 这部分是BroadcastRecord对象的详细信息。 e6067ba: 这可能是一个对象的内存地址或者是一个唯一标识符。 android.intent.action.SCREEN_OFF: 这是一个特定的动作，表示屏幕关闭的事件。当用户关闭屏幕时，系统会发送这个广播。 /u-1: 这可能指的是用户ID为-1，通常表示这是一个系统级别的广播。 from uid 1000 pid 965: 这表示广播是由用户ID为1000，进程ID为965的应用程序或服务发送的。 for 57 receivers: 这意味着有57个接收器（receivers）注册了对这个特定广播的监听，并将接收这个事件。 总的来说，这条日志记录了系统在处理一个屏幕关闭事件的广播，该广播是由用户ID为1000，进程ID为965的应用程序或服务发送的，并且有57个接收器将会接收到这个事件。这通常用于调试或监控系统事件。 Add broadcast &lt;BroadcastRecord{263938f u-1 android.intent.action.SCREEN_OFF}&gt; into [ordered | foreground], pending size 0 这条日志条目提供了有关Android系统中广播队列状态的信息。下面是对这条日志条目的详细解释： Add broadcast: 这表明一个广播事件被添加到了系统中的广播队列。 &lt;BroadcastRecord&#123;263938f u-1 android.intent.action.SCREEN_OFF&#125;&gt;: 这是被添加到队列中的广播记录对象的具体信息。 263938f: 这可能是广播记录对象的内存地址或唯一标识符。 u-1: 这通常表示广播是发送给所有用户的，u-1代表用户ID为-1，通常用于系统级别的广播。 android.intent.action.SCREEN_OFF: 这是广播的Action，表明这是一个屏幕关闭的广播，即当设备屏幕关闭时触发。 into [ordered | foreground]: 这部分说明了广播被添加到队列的方式。 ordered: 表示广播是有序的，即它们将按照接收器注册的顺序被处理。 foreground: 表示广播是前台广播，这意味着它将在前台进程中被处理，通常具有更高的优先级。 pending size 0: 这表示当前没有待处理的广播。pending指的是等待被处理的广播数量，size 0意味着队列中没有其他广播等待处理，当前添加的广播将是下一个被处理的。 综上所述，这条日志条目表明一个屏幕关闭的广播事件被添加到了一个有序且前台的广播队列中，并且当前没有其他广播在队列中等待处理。这通常用于调试或监控广播事件的处理情况。","tags":["Android","技术点"],"categories":["Android"]},{"title":"std::lock_guard 用法","path":"/2024/09/27/lock_guard 用法/","content":"std::lock_guard是C++11标准库中引入的一个RAII（资源获取即初始化）风格的互斥锁管理工具，用于简化对互斥锁（mutex）的管理。std::lock_guard在构造时自动获取锁，并在析构时释放锁，这确保了即使在发生异常的情况下，锁也能被正确释放。 以下是std::lock_guard的基本用法： 包含头文件在使用std::lock_guard之前，需要包含互斥锁的头文件： 1#include &lt;mutex&gt; 使用std::lock_guard 创建互斥锁：首先，你需要有一个std::mutex实例。 1std::mutex mtx; 创建std::lock_guard实例：当你需要对共享资源进行访问时，创建一个std::lock_guard对象，并将互斥锁的引用传递给它。 12345&#123; std::lock_guard&lt;std::mutex&gt; lk(mtx); // 在这个作用域内，mtx 被锁定 // 访问共享资源 &#125; // 作用域结束时，lock_guard 对象被销毁，mtx 被解锁 访问共享资源：在std::lock_guard对象的作用域内，互斥锁被保持锁定状态，你可以安全地访问共享资源。 自动解锁：当离开std::lock_guard对象的作用域时（例如，当作用域的代码块结束时），std::lock_guard对象会被销毁，互斥锁会自动释放。 示例代码12345678910111213141516171819202122232425#include &lt;iostream&gt; #include &lt;mutex&gt; #include &lt;thread&gt;std::mutex mtx; int shared_data = 0;void increment() &#123; for (int i = 0; i &lt; 10000; ++i) &#123; std::lock_guard&lt;std::mutex&gt; lk(mtx); ++shared_data; // 这里可以安全地修改 shared_data，因为 mtx 已被锁定 &#125; &#125;int main() &#123; std::thread t1(increment); std::thread t2(increment);t1.join(); t2.join();std::cout &lt;&lt; &quot;Final value of shared_data: &quot; &lt;&lt; shared_data &lt;&lt; std::endl; return 0; &#125; 在这个示例中，我们有两个线程t1和t2，它们都调用increment函数来递增共享数据shared_data。通过使用std::lock_guard，我们确保每次只有一个线程可以修改shared_data，从而避免了竞态条件。 std::lock_guard是线程安全的，并且它提供了一种异常安全的方式来管理锁，因为它保证在发生异常时锁也会被释放。这使得它成为保护共享资源访问的一个很好的选择。","tags":["C/C++基础"],"categories":["C/C++"]},{"title":"C++双冒号::的作用","path":"/2024/09/27/C双冒号的作用/","content":"全局命名空间全局命名空间是一个包含所有全局变量、函数和类型的隐式命名空间。如果想要在一个局部作用域内访问全局作用域的实体，可以使用双冒号::。 123456789101112#include &lt;iostream&gt;int var = 10; // global variableint main() &#123; int var = 20; // local variable std::cout &lt;&lt; &quot;Global var: &quot; &lt;&lt; ::var &lt;&lt; std::endl; // 全局参数var std::cout &lt;&lt; &quot;Local var: &quot; &lt;&lt; var &lt;&lt; std::endl; // 局部参数var return 0;&#125; 1234567char zhou; //全局变量 void sleep（） ｛ char zhou; //局部变量 char(局部变量) = char(局部变量) *char(局部变量) ; ::char(全局变量) =::char(全局变量) *char(局部变量); ｝ 上述代码中，全局变量和局部变量同名。通过::运算符，我们可以明确地引用全局变量。 &nbsp; 类成员访问在C++中，双冒号::也用于访问类的静态成员。 123456789101112131415161718class MyClass &#123;public: static int static_var; static void static_function() &#123; std::cout &lt;&lt; &quot;Static function&quot; &lt;&lt; std::endl; &#125;&#125;;int MyClass::static_var = 10; // define static member outside the classint main() &#123; std::cout &lt;&lt; &quot;Static var: &quot; &lt;&lt; MyClass::static_var &lt;&lt; std::endl; MyClass::static_function(); return 0;&#125; 在上述代码中，::被用来访问类的静态成员。注意静态成员需要在类外部定义。 &nbsp; 命名空间访问双冒号::还被用于明确指定某个命名空间中的实体。 123456789101112131415namespace MyNamespace &#123; int var = 10; void function() &#123; std::cout &lt;&lt; &quot;Function in namespace&quot; &lt;&lt; std::endl; &#125;&#125;&lt;span style=&quot;color: #7f7f7f&quot;&gt;指定某个命名空间中的实体&lt;/span&gt;int main() &#123; std::cout &lt;&lt; &quot;Var: &quot; &lt;&lt; MyNamespace::var &lt;&lt; std::endl; MyNamespace::function(); return 0;&#125; 在上述代码中，::被用来访问特定命名空间中的变量和函数。 &nbsp; 解决名称冲突.双冒号::还可以用于解决名称冲突，例如当使用了相同名称的两个库时。 123456789101112131415namespace Library1 &#123; void print() &#123; std::cout &lt;&lt; &quot;Print from Library1&quot; &lt;&lt; std::endl; &#125;&#125;namespace Library2 &#123; void print() &#123; std::cout &lt;&lt; &quot;Print from Library2&quot; &lt;&lt; std::endl; &#125;&#125;int main() &#123; Library1::print(); Library2::print(); return 0;&#125; 类方法定义前面一般是类名称，后面一般是该类的成员名称，C++为例避免不同的类有名称相同的成员而采用作用域的方式进行区分如：A,B表示两个类，在A,B中都有成员member。那么A::member就表示类A中的成员memberB::member就表示类B中的成员member 比如声明了一个类A，类A里声明了一个成员函数voidf()，但没有在类的声明里给出f的定义，那么在类外定义f时，就要写成voidA::f()，表示这个f()函数是类A的成员函数。例如 1234567891011121314151617181920class CA &#123; public: int ca_var; int add(int a, int b); int add(int a); &#125;; //那么在实现这个函数时，必须这样书写： int CA::add(int a, int b) &#123; return a + b; &#125; //另外，双冒号也常常用于在类变量内部作为当前类实例的元素进行表示，比如: int CA::add(int a) &#123; return a + ::ca_var; &#125; //表示当前类实例中的变量ca_var。 模板类中的双冒号在模板类中，双冒号用于访问基础模板类的成员。 123456789101112131415161718192021222324template&lt;class T&gt;class MyClass &#123;public: T var; MyClass(T x) &#123; this-&gt;var = x; &#125;&#125;;template&lt;&gt;class MyClass&lt;int&gt; &#123;public: int var; MyClass(int x) &#123; this-&gt;var = x; &#125; void print_base_var(MyClass&lt;double&gt;&amp; base_obj) &#123; std::cout &lt;&lt; &quot;Base var: &quot; &lt;&lt; base_obj.MyClass&lt;double&gt;::var &lt;&lt; std::endl; &#125;&#125;; 在上述代码中，特化的模板类MyClass&lt;int&gt;使用::来访问基础模板类MyClass&lt;double&gt;的成员。 &nbsp;","tags":["C/C++基础"],"categories":["C/C++"]},{"title":"Binder原理浅析","path":"/2024/09/27/Binder原理浅析/","content":"Binder原理浅析一、Binder优势 优势 描述 性能 一次数据拷贝，mmap内存映射 稳定性 基于 C&#x2F;S 架构，架构清晰、职责明确 安全性 为每个APP分配UID，鉴别进程身份的重要标志，阻止恶意程序通过猜测接收方地址获得连接 二、Binder概要设计2.1、进程隔离 操作系统中，进程与进程间内存是不共享的。两个进程就像两个平行的世界，A 进程没法直接访问 B 进程的数据，这就是进程隔离的通俗解释。A 进程和 B 进程之间要进行数据交互就得采用特殊的通信机制：进程间通信（IPC）。 .ruoeytrwvflv{zoom:50%;} 操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。为了保证安全性，它们之间是隔离的，用户空间需要经过系统调用才能访问到内核空间。 2.2、Binder通信模型Binder由四个组件Client、Server、Service Manager和Binder驱动程序组成 Client、Server和Service Manager实现在用户空间中，Binder驱动程序实现在内核空间中 Binder驱动程序和Service Manager在Android平台中已经实现，开发者只需要在用户空间实现自己的Client和Server Binder驱动程序提供设备文件&#x2F;dev&#x2F;binder与用户空间交互，Client、Server和Service Manager通过open和ioctl文件操作函数与Binder驱动程序进行通信 Client和Server之间的进程间通信通过Binder驱动程序间接实现 Service Manager是一个守护进程，用来管理Server，并向Client提供查询Server接口的能力 2.3、Binder通信过程 首先，一个进程使用 BINDER_SET_CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager； Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。 Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。 我们看到整个通信过程都需要 Binder 驱动的接入。下图能更加直观的展现整个通信过程(为了进一步抽象通信过程以及呈现上的方便，下图我们忽略了 Binder 实体及其引用的概念)： 2.4、Binder实现过程2.4.1、 实现图解client请求service服务，比如说Activity请求Activity ManagerService服务，由于Activity和ActivityManagerService是在两个不同的进程中的，那么下图是一个很直观的请求过程。 但是注意，一个进程是不能直接直接操作另一个进程的，比如说读取另一个进程的数据，或者往另一个进程的内存空间写数据，进程之间的通信要通过内核进程才可以，因此这里就要使用到进程通信工具Binder了如下图： 但是上面还有个问题就是client和service要直接和binder driver打交道，但是实际上client和service并不想知道binder相关协议，所以进一步client通过添加proxy代理，service通过添加stub来进一步处理与binder的交互。 这样的好处是client和service都可以不用直接去和binder打交道。上面的图好像已经很完善了，但是Android系统更进一步封装，不让client知道Binder的存在，Android系统提供了Manager来管理client。如下图： 这样client只需要交给manager来管理就好了，根本就不用关心进程通信相关的事，关于manager其实是很熟悉的，比如说activity的就是由ActivityManager来控制的，ActivityManager是通过Binder获取ActivityManagerService来控制activity的。这样就不用我们自己来使用Binder来ActivityManagerService通信了。 更进一步，client是如何具体获取到哪个service的呢？如下图所示： 在service和binder之间还有一个contextManager，也就是serviceManager，每一个service要先往serviceManager里面进行注册，注册完成之后由serviceManager统一管理。 在Android studio中可以通过adb指定打印出当前已经注册过serviceManager的service。 2.4.2、实现示例示例调用流程如下： 2.4.2.1 客户端Activity1234567891011121314151617181920212223242526272829303132333435//NoAidlActivity.javaprotected void onCreate(Bundle savedInstanceState) &#123; Intent intent = new Intent(this, MyService.class); bindService(intent, new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; //1. 从对象池拿到可复用的对象（享元模式） Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); Log.e(&quot;哈利迪&quot;, &quot;--- 我是客户端 NoAidlActivity , pid = &quot; + Process.myPid() + &quot;, thread = &quot; + Thread.currentThread().getName()); String str = &quot;666&quot;; Log.e(&quot;哈利迪&quot;, &quot;客户端向服务端发送：&quot; + str); //2. 往data写数据，作为请求参数 data.writeString(str); //3. 拿到服务端的IBinder句柄，调用transact //约定行为码是1；需要服务端的返回值，所以flags传0表示同步调用 service.transact(1, data, reply, 0); Log.e(&quot;哈利迪&quot;, &quot;--- 我是客户端 NoAidlActivity , pid = &quot; + Process.myPid() + &quot;, thread = &quot; + Thread.currentThread().getName()); //4. 从reply读取服务端的返回值 Log.e(&quot;哈利迪&quot;, &quot;客户端接收服务端返回：&quot; + reply.readString()); &#125; &#125;, Context.BIND_AUTO_CREATE);&#125; 如上代码，主要查看步骤2与步骤3。写入参数’666’至data，service.transact把data作为参数传递。 2.4.2.2 服务端运行的Service12345678class MyService extends Service &#123; @Override public IBinder onBind(Intent intent) &#123; //返回服务端的IBinder句柄 return new MyBinder(); &#125;&#125; 注册服务，让服务端Service运行在:remote进程，来实现跨进程 123&lt;service android:name=&quot;.binder.no_aidl.MyService&quot; android:process=&quot;:remote&quot; /&gt; 运行在服务端的Binder对象 12345678910111213141516171819202122class MyBinder extends Binder &#123; @Override protected boolean onTransact(int code, Parcel data, Parcel reply, int flags)&#123; if (code == 1) &#123;//如果是约定好的行为码1 Log.e(&quot;哈利迪&quot;, &quot;--- 我是服务端 MyBinder , pid = &quot; + Process.myPid() + &quot;, thread = &quot; + Thread.currentThread().getName()); //1. 从data读取客户端参数 Log.e(&quot;哈利迪&quot;, &quot;服务端收到：&quot; + data.readString()); String str = &quot;777&quot;; Log.e(&quot;哈利迪&quot;, &quot;服务端返回：&quot; + str); //2. 从reply向客户端写返回值 reply.writeString(str); //3. 处理完成 return true; &#125; return super.onTransact(code, data, reply, flags); &#125;&#125; 输出日志 Binder机制使用了Parcel来序列化数据，客户端在主线程调用了transact来请求（Parcel data传参），服务端在Binder线程调用onTransact来响应（Parcel reply回传结果）。 三、Binder源码流程3.1、Binder的调用流程图 3.2、客户端与驱动交互先来看客户端与驱动的交互。因为是跨进程调用（指定了:remote），示例里onServiceConnected回调回来的service对象是个BinderProxy代理实例（不跨进程的话会发生远程转本地，后面讲），我们以service.transact(1, data, reply, 0)这行调用作为入口跟进。 123456//BinderProxy.javapublic boolean transact(int code, Parcel data, Parcel reply, int flags)&#123; //调用了native方法 return transactNative(code, data, reply, flags);&#125; 这个native方法在android_util_Binder.cpp里注册 123456789101112131415161718192021//android_util_Binder.cpp//JNI注册static const JNINativeMethod gBinderProxyMethods[] = &#123; &#123; &quot;transactNative&quot;, &quot;(ILandroid/os/Parcel;Landroid/os/Parcel;I)Z&quot;, (void*)android_os_BinderProxy_transact&#125;,&#125;;//native方法具体实现static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj, jint code, jobject dataObj, jobject replyObj, jint flags)&#123; //转成native层的Parcel Parcel* data = parcelForJavaObject(env, dataObj); Parcel* reply = parcelForJavaObject(env, replyObj); //拿到native层的句柄BpBinder IBinder* target = (IBinder*) env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject); //调用BpBinder的transact status_t err = target-&gt;transact(code, *data, reply, flags);&#125; 继续跟BpBinder.cpp 1234567//BpBinder.cppstatus_t BpBinder::transact(...)&#123; //交给线程单例处理，驱动会根据mHandle值来找到对应的binder句柄 status_t status = IPCThreadState::self()-&gt;transact( mHandle, code, data, reply, flags);&#125; IPCThreadState是一个线程单例，负责与binder驱动进行具体的指令通信，跟进IPCThreadState.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//IPCThreadState.cppstatus_t IPCThreadState::transact(...)&#123; //将数据写入mOut，见1.1 err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL); //...先忽略one way异步调用的代码，只看有返回值的同步调用 //跟binder驱动交互，传入reply接收返回数据，见1.2 err = waitForResponse(reply);&#125;//1.1 将数据写入mOutstatus_t IPCThreadState::writeTransactionData(...)&#123; binder_transaction_data tr; //...打包各种数据（data size、buffer、offsets） tr.sender_euid = 0; //将BC_TRANSACTION指令写入mOut mOut.writeInt32(cmd); //将打包好的binder_transaction_data写入mOut mOut.write(&amp;tr, sizeof(tr));&#125;//1.2 跟binder驱动交互，传入reply接收返回数据status_t IPCThreadState::waitForResponse(...)&#123; //这个循环很重要，客户端就是在这里休眠等待服务端返回结果的 while (1) &#123; //跟驱动进行数据交互，往驱动写mOut，从驱动读mIn，见1.3 talkWithDriver(); //读取驱动回复的指令 cmd = (uint32_t)mIn.readInt32(); switch (cmd) &#123; case BR_TRANSACTION_COMPLETE: //表示驱动已经收到客户端的transact请求 //如果是one way异步调用，到这就可以结束了 if (!reply &amp;&amp; !acquireResult) goto finish; break; case BR_REPLY: //表示客户端收到服务端的返回结果 binder_transaction_data tr; //把服务端的数据读出来，打包进tr err = mIn.read(&amp;tr, sizeof(tr)); //再把tr的数据透传进reply reply-&gt;ipcSetDataReference(...); //结束 goto finish; &#125; &#125;&#125;//1.3 跟驱动进行数据交互，往驱动写mOut，从驱动读mInstatus_t IPCThreadState::talkWithDriver(bool doReceive)&#123; binder_write_read bwr; //指定写数据大小和写缓冲区 bwr.write_size = outAvail; bwr.write_buffer = (uintptr_t)mOut.data(); //指定读数据大小和读缓冲区 if (doReceive &amp;&amp; needRead) &#123; bwr.read_size = mIn.dataCapacity(); bwr.read_buffer = (uintptr_t)mIn.data(); &#125; else &#123; bwr.read_size = 0; bwr.read_buffer = 0; &#125; //ioctl的调用进入了binder驱动层的binder_ioctl ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr); if (bwr.write_consumed &gt; 0) &#123; //数据已经写入驱动，从mOut移除 if (bwr.write_consumed &lt; mOut.dataSize()) mOut.remove(0, bwr.write_consumed); else mOut.setDataSize(0); &#125; if (bwr.read_consumed &gt; 0) &#123; //从驱动读出数据存入mIn mIn.setDataSize(bwr.read_consumed); mIn.setDataPosition(0); &#125;&#125; ioctl的调用进入了binder驱动层的binder_ioctl 3.3、服务端与驱动交互服务端创建了一个线程注册进binder驱动，即binder线程，在ProcessState.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//IPCThreadState.cppvoid IPCThreadState::joinThreadPool(bool isMain)&#123; //向binder驱动写数据，表示当前线程需要注册进binder驱动 mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER); status_t result; do &#123; //进入死循环，等待指令的到来，见1.1 result = getAndExecuteCommand(); &#125; while (result != -ECONNREFUSED &amp;&amp; result != -EBADF); //向binder驱动写数据（退出循环，线程结束） mOut.writeInt32(BC_EXIT_LOOPER);&#125;//1.1 等待指令的到来status_t IPCThreadState::getAndExecuteCommand()&#123; //跟驱动进行数据交互，驱动会把指令写进mIn talkWithDriver(); //从mIn读出指令 cmd = mIn.readInt32(); //执行指令，见1.2 result = executeCommand(cmd); return result;&#125;//1.2 执行指令status_t IPCThreadState::executeCommand(int32_t cmd)&#123; //客户端发请求到驱动，驱动转发到服务端 switch ((uint32_t)cmd) &#123; case BR_TRANSACTION:&#123; //服务端收到BR_TRANSACTION指令 binder_transaction_data tr; //读出客户端请求的参数 result = mIn.read(&amp;tr, sizeof(tr)); //准备数据，向上传给Java层 Parcel buffer; Parcel reply; buffer.ipcSetDataReference(...); //cookie保存的是binder实体，对应服务端的native层对象就是BBinder reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, buffer, &amp;reply, tr.flags); //服务端向驱动写返回值，让驱动转发给客户端 sendReply(reply, 0); &#125; &#125;&#125;//1.3 服务端向驱动写返回值，让驱动转发给客户端status_t IPCThreadState::sendReply(const Parcel&amp; reply, uint32_t flags)&#123; err = writeTransactionData(BC_REPLY, flags, -1, 0, reply, &amp;statusBuffer); //服务端返回结果给客户端就行，不用等待客户端，所以传NULL return waitForResponse(NULL, NULL);&#125; 然后看下BBinder的transact是怎么向上传递到Java层的，在Binder.cpp中 123456789101112131415161718192021222324//Binder.cppstatus_t BBinder::transact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; switch (code) &#123; //ping指令用来判断连通性，即binder句柄是否还活着 case PING_TRANSACTION: reply-&gt;writeInt32(pingBinder()); break; default: //看这，通过JNI调用到Java层的execTransact，见1.1 err = onTransact(code, data, reply, flags); break; &#125; return err;&#125;//android_util_Binder.cpp//1.1 通过JNI调用到Java层的execTransactvirtual status_t onTransact(...)&#123; JNIEnv* env = javavm_to_jnienv(mVM); jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact, ...);&#125; 回到Java层，execTransact如下： 12345//android.os.Binder.javaprivate boolean execTransact(...) &#123; res = onTransact(code, data, reply, flags);&#125; 额外Binder问题 1、[007]一次Binder通信最大可以传输多大的数据？ 2、Android跨进程传大图思考及实现——附上原理分析 1.Binder驱动给每个进程最多分配4M的buffer空间大小；2.异步事务的空闲缓冲区空间大小最多为2M；3.Binder内核内存上限为1M-8k;4.异步事务缓冲区空间大小等于buffer_size&#x2F;2，具体值取决于buffer_size; TODO：Binder内核、IPCThreadState相关知识点的整理 参考资料： Android Binder 线程 写给 Android 应用工程师的 Binder 原理剖析 图解 | 不得错过的Binder浅析（一） 图解Android中的binder机制 红茶一杯话 Binder（ServiceManager 篇） Android进程间通信（IPC）机制Binder简要介绍和学习计划（罗升阳）","tags":["Android","framework"],"categories":["Android"]},{"title":"Android ATMS应用启动流程","path":"/2024/09/26/Android ATMS应用启动流程/","content":"Android ATMS应用启动流程1、Activity启动流程图大概流程图，在每个版本中流程都有一些出入，但整体大概流程还是有很多相同之处。 后续ActivityStackSupervisor处理启动activity请求会把该请求封装成一个ClientTransaction，然后执行Activity对应操作时就向ClientTransaction添加对应的XXActivityItem。而ActivityThread是ClientTransaction的处理者，继承了ClientTransactionHandler，根据XXActivityItem调用handleXXActivity，去执行activity的启动、onResume等生命周期活动。 2、ClientTransaction数据结构 ClientTransaction包含的数据 12345678910111、private List&lt;ClientTransactionItem&gt; mActivityCallbacks;保存需要传递的ClientTtransactionItem.比如：PauseActivityItem2、private ActivityLifecycleItem mLifecycleStateRequest下一个需要执行的ActivityLifecycleItem值3、private IApplicationThread mClient应用的Client对象4、private IBinder mActivityToken当前Activity的token值 如执行的ResumeActivityItem 12345678910// ResumeActivityItem.java// 实现Resume的方法执行：client.handleResumeActivity@Override public void execute(ClientTransactionHandler client, ActivityClientRecord r, PendingTransactionActions pendingActions) &#123; Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, &quot;activityResume&quot;); client.handleResumeActivity(r, true /* finalStateRequest */, mIsForward, mShouldSendCompatFakeFocus, &quot;RESUME_ACTIVITY&quot;); Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER); &#125; 3、Acttivity token流程关注完系统进程与应用进程的数据ClientTransaction交互，接下来就是token的流程 参考文章： Android—ATMS应用启动流程 Android AMS(ATMS)的应用启动流程解析","tags":["Android","framework"],"categories":["Android"]},{"title":"Android启动流程","path":"/2024/09/26/Android启动流程/","content":"Android启动流程Android源码基于14 一、Android架构 二、启动流程 Boot ROM：用于加载并执行Boot Loader。Android 设备上电后，开始执行固化在 CPU芯片里的 Boot ROM 中的预设代码，程序将 Boot Loader 代码加载到 ROM 中。这一步由芯片厂商负责设计和实现。 Boot Loader：用于将系统代码加载到 RAM 中。具体功能有：检查 RAM、初始化系统的硬件参数等功能，找到 Linux kernel 的代码，设置启动参数，并最终加载到RAM中。 Kernel：Linux 内核开始启动，初始化各种软硬件环境、加载驱动程序、挂载根文件系统、并执行 init 程序，由此开启 Android 的世界。 Init：内核初始化完成后，会启动名为init的用户空间进程。init进程是Android系统的第一个用户空间进程，它负责系统的进一步初始化和启动。init进程会读取系统配置文件（例如 init.rc），并根据其中的指令启动系统服务和应用程序。 12345init进程会孵化出ueventd、logd、healthd、installd、adbd、lmkd等用户守护进程；init进程还启动servicemanager(binder服务管家)、bootanim(开机动画)等重要服务init进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程(即虚拟机进程)，Zygote是所有Java进程的父进程，Zygote进程本身是由init进程孵化而来的。 Zygote：Zygote 是 Android 系统的启动进程，Zygote 会启动 System Servers。 System Servers：是Android系统的核心，负责启动和管理整个Java FrameWork，包含ActivityManagerService， WorkManagerService，PagerManagerService，PowerManagerService等服务。 三、Zygote进程(孵化器进程)init进程通过解析init.rc文件来启动各种服务和进程，包括Zygote 3.1 init.rc脚本解析init.rc源码地址 1234567891011121314151617/*system/core/rootdir/init.rc*/import /system/etc/init/hw/init.$&#123;ro.zygote&#125;.rc...on late-init # Now we can start zygote for devices with file based encryption trigger zygote-start // 1. 触发启动zygote...on zygote-start &amp;&amp; property:ro.crypto.state=encrypted &amp;&amp; property:ro.crypto.type=file wait_for_prop odsign.verification.done 1 # A/B update verifier that marks a successful boot. exec_start update_verifier_nonencrypted start statsd start netd start zygote // 2.启动zygote服务 start zygote_secondary... $&#123;ro.zygote&#125;的取值有4种，在init.rc的同级目录system&#x2F;core&#x2F;rootdir&#x2F;下，现在普遍使用的是init.zygote64_32.rc 12345678910111213141516171819202122232425# service zygote: 定义一个名为zygote的服务# /system/bin/app_process64： 这是启动Zygote进程的可执行文件# --start-system-server：Zygote进程启动后需要启动system_server进程，ZygoteInit.java会对参数进行处理service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote class main priority -20 user root group root readproc reserved_disk socket zygote stream 660 root system # 创建一个名为zygote的socket，用于其他进程与Zygote进程通信。 socket usap_pool_primary stream 660 root system onrestart exec_background - system system -- /system/bin/vdc volume abort_fuse onrestart write /sys/power/state on # NOTE: If the wakelock name here is changed, then also # update it in SystemSuspend.cpp #当zygote服务重启时，系统应重启的功能 onrestart write /sys/power/wake_lock zygote_kwl onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart media.tuner onrestart restart netd onrestart restart wificond task_profiles ProcessCapacityHigh MaxPerformance critical window=$&#123;zygote.critical_window.minute:-off&#125; target=zygote-fatal 3.2 启动Zygote进程init进程启动后，通过fork和execv来启动Zygote进程，如下简化代码所示： service.cpp源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354static bool ExpandArgsAndExecv(const std::vector&lt;std::string&gt;&amp; args, bool sigstop) &#123; std::vector&lt;std::string&gt; expanded_args; std::vector&lt;char*&gt; c_strings; expanded_args.resize(args.size()); c_strings.push_back(const_cast&lt;char*&gt;(args[0].data())); for (std::size_t i = 1; i &lt; args.size(); ++i) &#123; auto expanded_arg = ExpandProps(args[i]); if (!expanded_arg.ok()) &#123; LOG(FATAL) &lt;&lt; args[0] &lt;&lt; &quot;: cannot expand arguments&#x27;: &quot; &lt;&lt; expanded_arg.error(); &#125; expanded_args[i] = *expanded_arg; c_strings.push_back(expanded_args[i].data()); &#125; c_strings.push_back(nullptr); if (sigstop) &#123; kill(getpid(), SIGSTOP); &#125;\t// 2. c_strings[0]是执行程序路径，即如果启动的是zygote服务时，execve会运行/system/bin/app_process64 return execv(c_strings[0], c_strings.data()) == 0;&#125;void Service::RunService(const std::vector&lt;Descriptor&gt;&amp; descriptors, InterprocessFifo cgroups_activated, InterprocessFifo setsid_finished) &#123;\t... if (!ExpandArgsAndExecv(args_, sigstop_)) &#123; PLOG(ERROR) &lt;&lt; &quot;cannot execv(&#x27;&quot; &lt;&lt; args_[0] &lt;&lt; &quot;&#x27;). See the &#x27;Debugging init&#x27; section of init&#x27;s README.md for tips&quot;; &#125;&#125;Result&lt;void&gt; Service::Start() &#123;\t... pid_t pid = -1; if (namespaces_.flags) &#123; pid = clone(nullptr, nullptr, namespaces_.flags | SIGCHLD, nullptr); &#125; else &#123; pid = fork(); // 1.fork创建service进程（也就是zygote进程） &#125; if (pid == 0) &#123; umask(077); cgroups_activated.CloseWriteFd(); setsid_finished.CloseReadFd(); RunService(descriptors, std::move(cgroups_activated), std::move(setsid_finished)); _exit(127); &#125; else &#123; cgroups_activated.CloseReadFd(); setsid_finished.CloseWriteFd(); &#125;\t...&#125; 3.3 zygote进程3.3.1 native层：app_process启动zygote.main&#x2F;system&#x2F;bin&#x2F;app_process是Android中的一个关键可执行文件，负责启动Zygote进程和应用进程。 app_process源码地址 12345678910111213141516171819202122232425262728293031/*frameworks/base/cmds/app_process/app_main.cpp*/int main(int argc, char* const argv[])&#123; ... // Parse runtime arguments. Stop at first unrecognized option. bool zygote = false; ... while (i &lt; argc) &#123; const char* arg = argv[i++]; if (strcmp(arg, &quot;--zygote&quot;) == 0) &#123; zygote = true; // 参数标识启动zygote进程 niceName = ZYGOTE_NICE_NAME; &#125; else if (strcmp(arg, &quot;--start-system-server&quot;) == 0) &#123; startSystemServer = true; //参数标识启动system_server进程 &#125; ... &#125; ... if (!niceName.isEmpty()) &#123; runtime.setArgv0(niceName.string(), true /* setProcName */); // 进程名app_process修改为zygote &#125; if (zygote) &#123; // 启动Zygote，执行AndroidRuntime.start函数 runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote); &#125; else if (className) &#123; runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote); &#125; else &#123; ... &#125;&#125; 我们进一步来看AndroidRuntime的start流程代码： AndroidRuntime源码 1234567891011121314151617181920212223242526272829303132333435363738/*frameworks/base/core/jni/AndroidRuntime.cpp*/void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123; ... /* start the virtual machine */ JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; if (startVm(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != 0) &#123; // 1.启动VM虚拟机 return; &#125; onVmCreated(env); /* * Register android functions. */ if (startReg(env) &lt; 0) &#123; // 2.注册框架JNI调用到虚拟机中 ALOGE(&quot;Unable to register all android natives &quot;); return; &#125; ... char* slashClassName = toSlashClassName(className != NULL ? className : &quot;&quot;); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) &#123; ALOGE(&quot;JavaVM unable to locate class &#x27;%s&#x27; &quot;, slashClassName); &#125; else &#123; // 3.JNI调用进入java层执行ZygoteInit的main函数 jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;); if (startMeth == NULL) &#123; ALOGE(&quot;JavaVM unable to find main() in &#x27;%s&#x27; &quot;, className); /* keep going */ &#125; else &#123; env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); ... &#125; ...&#125; 从代码中可以看到AndroidRuntime#start方法中主要完成三件事情： 启动进程的VM虚拟机； 注册Android系统框架JNI调用到虚拟机中； 通过JNI调用进入java层执行ZygoteInit的main函数； 1234AI通义回答：Q：android 系统启动时 app_process是运行在哪个进程中A:当app_process被执行时，它实际上是在一个新的进程中运行。这个新进程就是Zygote进程。在Zygote启动的过程中，app_process会根据传递给它的参数来决定其行为。例如，如果带有--zygote标志，那么app_process就会初始化Zygote并开始监听socket连接，等待Activity Manager Service (AMS) 发起的请求以创建新的应用进程。因此，可以明确地说，在Android系统启动过程中，app_process是运行在Zygote进程中。 3.3.2 java层：ZyogeInit由3.3.1调用执行java层ZygoteInit的main函数 ZyogeInit.java源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/*frameworks/base/core/java/com/android/internal/os/ZygoteInit.java*/ public static void main(String[] argv) &#123; ZygoteServer zygoteServer = null;\t... try &#123; ... for (int i = 1; i &lt; argv.length; i++) &#123; // 在init.rc文件中，有--start-system-server参数，表示要创建SystemServer if (&quot;start-system-server&quot;.equals(argv[i])) &#123; startSystemServer = true; &#125; else if (&quot;--enable-lazy-preload&quot;.equals(argv[i])) &#123; enableLazyPreload = true; &#125; &#125; ... if (!enableLazyPreload) &#123; ... preload(bootTimingsTraceLog); // 1.预加载资源 ... &#125; ... zygoteServer = new ZygoteServer(isPrimaryZygote); // 2.创建Socket服务端 if (startSystemServer) &#123; Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer); // 3.fork启动system_server进程 ... &#125; ... //4. sokcet服务端等待AMS请求（AMS会通过socket请求Zygote来创建应用程序进程） caller = zygoteServer.runSelectLoop(abiList); &#125; catch (Throwable ex) &#123; Log.e(TAG, &quot;System zygote died with fatal exception&quot;, ex); throw ex; &#125; finally &#123; if (zygoteServer != null) &#123; zygoteServer.closeServerSocket(); &#125; &#125; // We&#x27;re in the child process and have exited the select loop. Proceed to execute the // command. if (caller != null) &#123; caller.run(); &#125; &#125; static void preload(TimingsTraceLog bootTimingsTraceLog) &#123; beginPreload(); preloadClasses(); // 1.预加载system/etc/preloaded-classes文件中定义的各个系统类\t... preloadResources(); // 2.预加载系统中定义的各个drawables、color资源 ... nativePreloadAppProcessHALs(); // 3.预加载某些硬件抽象层（HAL）模块\t... maybePreloadGraphicsDriver(); // 4.预加载图形驱动程序\t... preloadSharedLibraries(); // 5.预加载一些共享库（shared libraries） preloadTextResources(); //6.预加载一些常用的文本资源，如字体、字符串 WebViewFactory.prepareWebViewInZygote(); endPreload(); sPreloadComplete = true; &#125; 从代码中可以看到ZygoteInit#main方法中主要fork启动system_server进程： zygote进程中预加载类、主题资源、字体资源等 创建socket服务端，用于跨进程通信； fork创建启动系统system_server进程； Sokcet服务端进入循环监听等待，等待后续AMS请求（AMS会通过socket请求Zygote来创建应用程序进程）。 3.3.3 system_server进程的启动继续分析forkSystemServer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*frameworks/base/core/java/com/android/internal/os/ZygoteInit.java*/ private static Runnable forkSystemServer(String abiList, String socketName, ZygoteServer zygoteServer) &#123; ... int pid; try &#123; ... /* Request to fork the system server process */ // 1.fork创建system_server进程 pid = Zygote.forkSystemServer( parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids, parsedArgs.mRuntimeFlags, null, parsedArgs.mPermittedCapabilities, parsedArgs.mEffectiveCapabilities); &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; /* For child process */ if (pid == 0) &#123; if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; // 2.pid为0代表在新创建的system_server进程中，继续通过handleSystemServerProcess进一步处理 zygoteServer.closeServerSocket(); return handleSystemServerProcess(parsedArgs); &#125; return null; &#125; private static Runnable handleSystemServerProcess(ZygoteArguments parsedArgs) &#123; ... &#125; else &#123; return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion, parsedArgs.mDisabledCompatChanges, parsedArgs.mRemainingArgs, cl); &#125; &#125; public static Runnable zygoteInit(int targetSdkVersion, long[] disabledCompatChanges, String[] argv, ClassLoader classLoader) &#123; ... RuntimeInit.commonInit(); // 1.触发启动进程的Binder线程池 ZygoteInit.nativeZygoteInit(); // 2.通过反射创建&quot;com.android.server.SystemServer&quot;类对象并执行其main函数 return RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv, classLoader); &#125; ZygoteInit.nativeZygoteInit()：触发进程Binder线程池，后续Binder再分析。 RuntimeInit.applicationInit()：反射方式执行SystemServer的main函数 接下来是SystemServer启动的main方法 12345678910111213141516171819202122232425262728293031323334353637/*frameworks/base/services/java/com/android/server/SystemServer.java*/public static void main(String[] args) &#123; new SystemServer().run();&#125;private void run() &#123; ... // 1.创建主线程Looper Looper.prepareMainLooper(); // 2.创建系统Context上下文 createSystemContext(); // 3.创建SystemServiceManager，用于后续系统服务（AMS、WMS等）的创建、启动和生命周期管理 mSystemServiceManager = new SystemServiceManager(mSystemContext); mSystemServiceManager.setStartInfo(mRuntimeRestart, mRuntimeStartElapsedTime, mRuntimeStartUptime); LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); // 4.服务根据优先级被分成3批来启动： try &#123; t.traceBegin(&quot;StartServices&quot;); //启动引导服务 startBootstrapServices(t); //启动核心服务 startCoreServices(t); //启动其他服务 startOtherServices(t); //启动 APEX 服务 startApexServices(t); &#125; catch (Throwable ex) &#123; Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex); throw ex; &#125; finally &#123; t.traceEnd(); // StartServices &#125; // 5.开启looper循环 Looper.loop();&#125; 3.4 System Server启动的主要服务以下为System Server启动的主要服务列表，具体实现可在源码中查看。 服务名称 功能说明 Activity Manager Service (AMS) 管理应用程序的生命周期，包括启动和停止应用、管理任务和活动栈、处理广播等 Package Manager Service (PMS) 管理应用包的安装、卸载、更新、权限分配等 System Config Service 管理系统配置和资源 Power Manager Service 管理设备的电源状态和电源策略，如休眠、唤醒等 Display Manager Service 管理显示设备，如屏幕亮度、显示模式等 User Manager Service 管理用户账户和用户信息 Battery Service 监控和管理电池状态和电池使用情况 Vibrator Service 控制设备的振动功能 Sensor Service 管理设备的传感器，如加速度计、陀螺仪等 Window Manager Service (WMS) 管理窗口和显示内容，包括窗口的创建、删除、布局等 Input Manager Service 管理输入设备，如触摸屏、键盘等 Alarm Manager Service 提供定时任务调度功能 Connectivity Service 管理网络连接，如 Wi-Fi、移动数据等 Network Management Service 管理网络接口和网络连接 Telephony Registry 管理电话和短信服务 Input Method Manager Service (IMMS) 管理输入法框架 Accessibility Manager Service 管理无障碍服务，为有特殊需要的用户提供辅助功能 Mount Service 管理存储设备的挂载和卸载 Location Manager Service 管理位置服务，如 GPS 和网络定位 Search Manager Service 管理系统搜索功能 Clipboard Service 管理剪贴板功能 DevicePolicy Manager Service 管理设备的安全策略和企业管理功能 Status Bar Service 管理状态栏显示和操作 Wallpaper Manager Service 管理壁纸设置和操作 Media Router Service 管理媒体设备路由 四、总结Android系统启动的核心流程如下： Linux内核启动 init进程启动 init进程fork出Zygote进程 Zygote进程fork出SystemServer进程 SystemServer进程启动各项服务（PMS、AMS等） AMS服务启动Launcher桌面 参考文章： Android系统启动流程（基于Android 11） Android启动过程-万字长文(Android14) http://gityuan.com/android/","tags":["Android","framework"],"categories":["Android"]},{"title":"2023年回顾","path":"/2024/01/01/2023年回顾/","content":"2023年回顾​\t2023年从奇酷离职，换了现在的公司。在奇酷待了5年，想起进公司之前，老同事积极内推我进奇酷，想想还是很感激以前的老同事。前路漫漫，一起共勉。 ​\t这几年从系统应用慢慢的转向fwk开发，负责几个fwk模块的开发内容，也一直在重新梳理fwk的技术点，Reading the fuck source code。来到新公司后，又开始从事新的模块SystemUI，也同时修改fwk，公司不区分是app、fwk层、native，哪里有问题就去改哪里，这样就太有好处了，总算能够更加全面的深入系统。 ​\t2023独立完成了SystemUI的整个功能样式的修改，后续又解决后台应用性能优化问题，还是有一些成就感，2024努力，努力，再努力。","tags":["总结"],"categories":["生活杂谈"]}]