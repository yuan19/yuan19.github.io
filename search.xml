<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android启动流程</title>
    <url>/2024/09/26/Android%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Android启动流程"><a href="#Android启动流程" class="headerlink" title="Android启动流程"></a>Android启动流程</h1><p><a href="http://aospxref.com/android-14.0.0_r2/xref/">Android源码基于14</a></p>
<h2 id="一、Android架构"><a href="#一、Android架构" class="headerlink" title="一、Android架构"></a>一、Android架构</h2><img src="/2024/09/26/Android%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/705472d33f524bd1ab8dcaf7b2e15d8a.png" class="" title="705472d33f524bd1ab8dcaf7b2e15d8a">

<h2 id="二、启动流程"><a href="#二、启动流程" class="headerlink" title="二、启动流程"></a>二、启动流程</h2><img src="/2024/09/26/Android%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/image-20240919092238815.png" class="" title="image-20240919092238815">

<ul>
<li><p>Boot ROM：用于加载并执行Boot Loader。Android 设备上电后，开始执行固化在 CPU芯片里的 Boot ROM 中的预设代码，程序将 Boot Loader 代码加载到 ROM 中。这一步由芯片厂商负责设计和实现。</p>
</li>
<li><p>Boot Loader：用于将系统代码加载到 RAM 中。具体功能有：检查 RAM、初始化系统的硬件参数等功能，找到 Linux kernel 的代码，设置启动参数，并最终加载到RAM中。</p>
</li>
<li><p>Kernel：Linux 内核开始启动，初始化各种软硬件环境、加载驱动程序、挂载根文件系统、并执行 init 程序，由此开启 Android 的世界。</p>
</li>
<li><p>Init：内核初始化完成后，会启动名为init的用户空间进程。init进程是Android系统的第一个用户空间进程，它负责系统的进一步初始化和启动。init进程会读取系统配置文件（例如 init.rc），并根据其中的指令启动系统服务和应用程序。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">init进程会孵化出ueventd、logd、healthd、installd、adbd、lmkd等用户守护进程；</span><br><span class="line"></span><br><span class="line">init进程还启动servicemanager(binder服务管家)、bootanim(开机动画)等重要服务</span><br><span class="line"></span><br><span class="line">init进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程(即虚拟机进程)，Zygote是所有Java进程的父进程，Zygote进程本身是由init进程孵化而来的。</span><br></pre></td></tr></table></figure>


</li>
<li><p>Zygote：Zygote 是 Android 系统的启动进程，Zygote 会启动 System Servers。</p>
</li>
<li><p>System Servers：是Android系统的核心，负责启动和管理整个Java FrameWork，包含ActivityManagerService， WorkManagerService，PagerManagerService，PowerManagerService等服务。</p>
</li>
</ul>
<h2 id="三、Zygote进程-孵化器进程"><a href="#三、Zygote进程-孵化器进程" class="headerlink" title="三、Zygote进程(孵化器进程)"></a>三、Zygote进程(孵化器进程)</h2><p>init进程通过解析init.rc文件来启动各种服务和进程，包括Zygote</p>
<h3 id="3-1-init-rc脚本解析"><a href="#3-1-init-rc脚本解析" class="headerlink" title="3.1 init.rc脚本解析"></a>3.1 init.rc脚本解析</h3><p><a href="http://aospxref.com/android-14.0.0_r2/xref/system/core/rootdir/init.rc">init.rc源码地址</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*system/core/rootdir/init.rc*/</span><br><span class="line">import /system/etc/init/hw/init.$&#123;ro.zygote&#125;.rc</span><br><span class="line">...</span><br><span class="line">on late-init</span><br><span class="line">    # Now we can start zygote for devices with file based encryption</span><br><span class="line">    trigger zygote-start // 1. 触发启动zygote</span><br><span class="line">...</span><br><span class="line">on zygote-start &amp;&amp; property:ro.crypto.state=encrypted &amp;&amp; property:ro.crypto.type=file</span><br><span class="line">    wait_for_prop odsign.verification.done 1</span><br><span class="line">    # A/B update verifier that marks a successful boot.</span><br><span class="line">    exec_start update_verifier_nonencrypted</span><br><span class="line">    start statsd</span><br><span class="line">    start netd</span><br><span class="line">    start zygote // 2.启动zygote服务</span><br><span class="line">    start zygote_secondary</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>$&#123;ro.zygote&#125;</code>的取值有4种，在init.rc的同级目录system&#x2F;core&#x2F;rootdir&#x2F;下，现在普遍使用的是init.zygote64_32.rc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># service zygote: 定义一个名为zygote的服务</span><br><span class="line"># /system/bin/app_process64： 这是启动Zygote进程的可执行文件</span><br><span class="line"># --start-system-server：Zygote进程启动后需要启动system_server进程，ZygoteInit.java会对参数进行处理</span><br><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">    user root</span><br><span class="line">    group root readproc reserved_disk</span><br><span class="line">    socket zygote stream 660 root system    # 创建一个名为zygote的socket，用于其他进程与Zygote进程通信。</span><br><span class="line">    socket usap_pool_primary stream 660 root system</span><br><span class="line">    onrestart exec_background - system system -- /system/bin/vdc volume abort_fuse</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    # NOTE: If the wakelock name here is changed, then also</span><br><span class="line">    # update it in SystemSuspend.cpp</span><br><span class="line">    </span><br><span class="line">    #当zygote服务重启时，系统应重启的功能</span><br><span class="line">    onrestart write /sys/power/wake_lock zygote_kwl</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart media.tuner</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    task_profiles ProcessCapacityHigh MaxPerformance</span><br><span class="line">    critical window=$&#123;zygote.critical_window.minute:-off&#125; target=zygote-fatal</span><br></pre></td></tr></table></figure>

<h3 id="3-2-启动Zygote进程"><a href="#3-2-启动Zygote进程" class="headerlink" title="3.2 启动Zygote进程"></a>3.2 启动Zygote进程</h3><p>init进程启动后，通过fork和execv来启动Zygote进程，如下简化代码所示：</p>
<p><a href="http://aospxref.com/android-14.0.0_r2/xref/system/core/init/service.cpp">service.cpp源码</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">ExpandArgsAndExecv</span><span class="params">(<span class="type">const</span> std::vector&lt;std::string&gt;&amp; args, <span class="type">bool</span> sigstop)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; expanded_args;</span><br><span class="line">    std::vector&lt;<span class="type">char</span>*&gt; c_strings;</span><br><span class="line"></span><br><span class="line">    expanded_args.<span class="built_in">resize</span>(args.<span class="built_in">size</span>());</span><br><span class="line">    c_strings.<span class="built_in">push_back</span>(<span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(args[<span class="number">0</span>].<span class="built_in">data</span>()));</span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; args.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> expanded_arg = <span class="built_in">ExpandProps</span>(args[i]);</span><br><span class="line">        <span class="keyword">if</span> (!expanded_arg.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(FATAL) &lt;&lt; args[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;: cannot expand arguments&#x27;: &quot;</span> &lt;&lt; expanded_arg.<span class="built_in">error</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        expanded_args[i] = *expanded_arg;</span><br><span class="line">        c_strings.<span class="built_in">push_back</span>(expanded_args[i].<span class="built_in">data</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    c_strings.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigstop) &#123;</span><br><span class="line">        <span class="built_in">kill</span>(<span class="built_in">getpid</span>(), SIGSTOP);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 2. c_strings[0]是执行程序路径，即如果启动的是zygote服务时，execve会运行/system/bin/app_process64</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">execv</span>(c_strings[<span class="number">0</span>], c_strings.<span class="built_in">data</span>()) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Service::RunService</span><span class="params">(<span class="type">const</span> std::vector&lt;Descriptor&gt;&amp; descriptors,</span></span></span><br><span class="line"><span class="params"><span class="function">                         InterprocessFifo cgroups_activated, InterprocessFifo setsid_finished)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ExpandArgsAndExecv</span>(args_, sigstop_)) &#123;</span><br><span class="line">        <span class="built_in">PLOG</span>(ERROR) &lt;&lt; <span class="string">&quot;cannot execv(&#x27;&quot;</span> &lt;&lt; args_[<span class="number">0</span>]</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;&#x27;). See the &#x27;Debugging init&#x27; section of init&#x27;s README.md for tips&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Result&lt;<span class="type">void</span>&gt; <span class="title">Service::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (namespaces_.flags) &#123;</span><br><span class="line">        pid = <span class="built_in">clone</span>(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, namespaces_.flags | SIGCHLD, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pid = fork(); <span class="comment">// 1.fork创建service进程（也就是zygote进程）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">umask</span>(<span class="number">077</span>);</span><br><span class="line">        cgroups_activated.<span class="built_in">CloseWriteFd</span>();</span><br><span class="line">        setsid_finished.<span class="built_in">CloseReadFd</span>();</span><br><span class="line">        <span class="built_in">RunService</span>(descriptors, std::<span class="built_in">move</span>(cgroups_activated), std::<span class="built_in">move</span>(setsid_finished));</span><br><span class="line">        _exit(<span class="number">127</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cgroups_activated.<span class="built_in">CloseReadFd</span>();</span><br><span class="line">        setsid_finished.<span class="built_in">CloseWriteFd</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-zygote进程"><a href="#3-3-zygote进程" class="headerlink" title="3.3 zygote进程"></a>3.3 zygote进程</h3><h4 id="3-3-1-native层：app-process启动zygote-main"><a href="#3-3-1-native层：app-process启动zygote-main" class="headerlink" title="3.3.1 native层：app_process启动zygote.main"></a>3.3.1 native层：app_process启动zygote.main</h4><p><strong>&#x2F;system&#x2F;bin&#x2F;app_process</strong>是Android中的一个<strong>关键可执行文件</strong>，负责启动Zygote进程和应用进程。</p>
<p><a href="http://aospxref.com/android-14.0.0_r2/xref/frameworks/base/cmds/app_process/app_main.cpp">app_process源码地址</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/cmds/app_process/app_main.cpp*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* <span class="type">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Parse runtime arguments.  Stop at first unrecognized option.</span></span><br><span class="line">    <span class="type">bool</span> zygote = <span class="literal">false</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--zygote&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>; <span class="comment">// 参数标识启动zygote进程</span></span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--start-system-server&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>; <span class="comment">//参数标识启动system_server进程</span></span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!niceName.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        runtime.<span class="built_in">setArgv0</span>(niceName.<span class="built_in">string</span>(), <span class="literal">true</span> <span class="comment">/* setProcName */</span>); <span class="comment">// 进程名app_process修改为zygote</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        <span class="comment">// 启动Zygote，执行AndroidRuntime.start函数</span></span><br><span class="line">        runtime.<span class="built_in">start</span>(<span class="string">&quot;com.android.internal.os.ZygoteInit&quot;</span>, args, zygote); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.<span class="built_in">start</span>(<span class="string">&quot;com.android.internal.os.RuntimeInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们进一步来看AndroidRuntime的start流程代码：</p>
<p><a href="https://aospxref.com/android-14.0.0_r2/xref/frameworks/base/core/jni/AndroidRuntime.cpp">AndroidRuntime源码</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/jni/AndroidRuntime.cpp*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* className, <span class="type">const</span> Vector&lt;String8&gt;&amp; options, <span class="type">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* start the virtual machine */</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.<span class="built_in">Init</span>(<span class="literal">NULL</span>);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">startVm</span>(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != <span class="number">0</span>) &#123; <span class="comment">// 1.启动VM虚拟机</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">onVmCreated</span>(env);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Register android functions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">startReg</span>(env) &lt; <span class="number">0</span>) &#123; <span class="comment">// 2.注册框架JNI调用到虚拟机中</span></span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Unable to register all android natives\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">char</span>* slashClassName = <span class="built_in">toSlashClassName</span>(className != <span class="literal">NULL</span> ? className : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    jclass startClass = env-&gt;<span class="built_in">FindClass</span>(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;JavaVM unable to locate class &#x27;%s&#x27;\n&quot;</span>, slashClassName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3.JNI调用进入java层执行ZygoteInit的main函数</span></span><br><span class="line">        jmethodID startMeth = env-&gt;<span class="built_in">GetStaticMethodID</span>(startClass, <span class="string">&quot;main&quot;</span>,</span><br><span class="line">            <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;JavaVM unable to find main() in &#x27;%s&#x27;\n&quot;</span>, className);</span><br><span class="line">            <span class="comment">/* keep going */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            env-&gt;<span class="built_in">CallStaticVoidMethod</span>(startClass, startMeth, strArray);</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看到AndroidRuntime#start方法中主要完成三件事情：</p>
<ol>
<li>启动进程的VM虚拟机；</li>
<li>注册Android系统框架JNI调用到虚拟机中；</li>
<li>通过JNI调用进入java层执行ZygoteInit的main函数；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AI通义回答：</span><br><span class="line">Q：android 系统启动时 app_process是运行在哪个进程中</span><br><span class="line">A:当app_process被执行时，它实际上是在一个新的进程中运行。这个新进程就是Zygote进程。在Zygote启动的过程中，app_process会根据传递给它的参数来决定其行为。例如，如果带有--zygote标志，那么app_process就会初始化Zygote并开始监听socket连接，等待Activity Manager Service (AMS) 发起的请求以创建新的应用进程。</span><br><span class="line">因此，可以明确地说，在Android系统启动过程中，app_process是运行在Zygote进程中。</span><br></pre></td></tr></table></figure>



<h4 id="3-3-2-java层：ZyogeInit"><a href="#3-3-2-java层：ZyogeInit" class="headerlink" title="3.3.2 java层：ZyogeInit"></a>3.3.2 java层：ZyogeInit</h4><p>由3.3.1调用执行java层ZygoteInit的main函数</p>
<p><a href="http://aospxref.com/android-14.0.0_r2/xref/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java#main">ZyogeInit.java源码</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/com/android/internal/os/ZygoteInit.java*/</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> &#123;</span><br><span class="line">       <span class="type">ZygoteServer</span> <span class="variable">zygoteServer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	...</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">		...</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">			<span class="comment">// 在init.rc文件中，有--start-system-server参数，表示要创建SystemServer</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="string">&quot;start-system-server&quot;</span>.equals(argv[i])) &#123;</span><br><span class="line">                   startSystemServer = <span class="literal">true</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;--enable-lazy-preload&quot;</span>.equals(argv[i])) &#123;</span><br><span class="line">                   enableLazyPreload = <span class="literal">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">		...</span><br><span class="line">           <span class="keyword">if</span> (!enableLazyPreload) &#123;</span><br><span class="line">			...</span><br><span class="line">               preload(bootTimingsTraceLog); <span class="comment">// 1.预加载资源</span></span><br><span class="line">			...</span><br><span class="line">           &#125;</span><br><span class="line">		...</span><br><span class="line">           zygoteServer = <span class="keyword">new</span> <span class="title class_">ZygoteServer</span>(isPrimaryZygote); <span class="comment">// 2.创建Socket服务端</span></span><br><span class="line">		</span><br><span class="line">           <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">               <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> forkSystemServer(abiList, zygoteSocketName, zygoteServer); <span class="comment">// 3.fork启动system_server进程</span></span><br><span class="line">			...</span><br><span class="line">           &#125;</span><br><span class="line">		...</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//4. sokcet服务端等待AMS请求（AMS会通过socket请求Zygote来创建应用程序进程）</span></span><br><span class="line">           caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">           Log.e(TAG, <span class="string">&quot;System zygote died with fatal exception&quot;</span>, ex);</span><br><span class="line">           <span class="keyword">throw</span> ex;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (zygoteServer != <span class="literal">null</span>) &#123;</span><br><span class="line">               zygoteServer.closeServerSocket();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// We&#x27;re in the child process and have exited the select loop. Proceed to execute the</span></span><br><span class="line">       <span class="comment">// command.</span></span><br><span class="line">       <span class="keyword">if</span> (caller != <span class="literal">null</span>) &#123;</span><br><span class="line">           caller.run();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preload</span><span class="params">(TimingsTraceLog bootTimingsTraceLog)</span> &#123;</span><br><span class="line">       beginPreload();</span><br><span class="line">       preloadClasses(); <span class="comment">// 1.预加载system/etc/preloaded-classes文件中定义的各个系统类</span></span><br><span class="line">	...</span><br><span class="line">       preloadResources(); <span class="comment">// 2.预加载系统中定义的各个drawables、color资源</span></span><br><span class="line">       ...</span><br><span class="line">       nativePreloadAppProcessHALs(); <span class="comment">// 3.预加载某些硬件抽象层（HAL）模块</span></span><br><span class="line">	...</span><br><span class="line">       maybePreloadGraphicsDriver(); <span class="comment">// 4.预加载图形驱动程序</span></span><br><span class="line">	...</span><br><span class="line">       preloadSharedLibraries(); <span class="comment">// 5.预加载一些共享库（shared libraries）</span></span><br><span class="line">       preloadTextResources(); <span class="comment">//6.预加载一些常用的文本资源，如字体、字符串</span></span><br><span class="line">       WebViewFactory.prepareWebViewInZygote();</span><br><span class="line">       endPreload();</span><br><span class="line"></span><br><span class="line">       sPreloadComplete = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从代码中可以看到ZygoteInit#main方法中主要fork启动system_server进程：</p>
<ol>
<li>zygote进程中预加载类、主题资源、字体资源等</li>
<li>创建socket服务端，用于跨进程通信；</li>
<li><strong>fork创建启动系统system_server进程；</strong></li>
<li>Sokcet服务端进入循环监听等待，等待后续AMS请求（<strong>AMS会通过socket请求Zygote来创建应用程序进程</strong>）。</li>
</ol>
<h4 id="3-3-3-system-server进程的启动"><a href="#3-3-3-system-server进程的启动" class="headerlink" title="3.3.3 system_server进程的启动"></a>3.3.3 system_server进程的启动</h4><p>继续分析forkSystemServer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/com/android/internal/os/ZygoteInit.java*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title function_">forkSystemServer</span><span class="params">(String abiList, String socketName,</span></span><br><span class="line"><span class="params">            ZygoteServer zygoteServer)</span> &#123;</span><br><span class="line">		...</span><br><span class="line">        <span class="type">int</span> pid;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			...</span><br><span class="line">            <span class="comment">/* Request to fork the system server process */</span></span><br><span class="line">			<span class="comment">// 1.fork创建system_server进程</span></span><br><span class="line">            pid = Zygote.forkSystemServer(</span><br><span class="line">                    parsedArgs.mUid, parsedArgs.mGid,</span><br><span class="line">                    parsedArgs.mGids,</span><br><span class="line">                    parsedArgs.mRuntimeFlags,</span><br><span class="line">                    <span class="literal">null</span>,</span><br><span class="line">                    parsedArgs.mPermittedCapabilities,</span><br><span class="line">                    parsedArgs.mEffectiveCapabilities);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* For child process */</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">                waitForSecondaryZygote(socketName);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 2.pid为0代表在新创建的system_server进程中，继续通过handleSystemServerProcess进一步处理</span></span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">            <span class="keyword">return</span> handleSystemServerProcess(parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title function_">handleSystemServerProcess</span><span class="params">(ZygoteArguments parsedArgs)</span> &#123;</span><br><span class="line">		...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,</span><br><span class="line">                    parsedArgs.mDisabledCompatChanges,</span><br><span class="line">                    parsedArgs.mRemainingArgs, cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runnable <span class="title function_">zygoteInit</span><span class="params">(<span class="type">int</span> targetSdkVersion, <span class="type">long</span>[] disabledCompatChanges,</span></span><br><span class="line"><span class="params">            String[] argv, ClassLoader classLoader)</span> &#123;</span><br><span class="line">		...</span><br><span class="line">        RuntimeInit.commonInit();</span><br><span class="line">		<span class="comment">// 1.触发启动进程的Binder线程池 </span></span><br><span class="line">        ZygoteInit.nativeZygoteInit();</span><br><span class="line">		<span class="comment">// 2.通过反射创建&quot;com.android.server.SystemServer&quot;类对象并执行其main函数</span></span><br><span class="line">        <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv,</span><br><span class="line">                classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>ZygoteInit.nativeZygoteInit()：触发进程Binder线程池，后续Binder再分析。</li>
<li>RuntimeInit.applicationInit()：反射方式执行SystemServer的main函数</li>
</ol>
<p>接下来是SystemServer启动的main方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/services/java/com/android/server/SystemServer.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SystemServer</span>().run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="comment">// 1.创建主线程Looper</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    <span class="comment">// 2.创建系统Context上下文</span></span><br><span class="line">    createSystemContext();</span><br><span class="line">    <span class="comment">// 3.创建SystemServiceManager，用于后续系统服务（AMS、WMS等）的创建、启动和生命周期管理</span></span><br><span class="line">    mSystemServiceManager = <span class="keyword">new</span> <span class="title class_">SystemServiceManager</span>(mSystemContext);</span><br><span class="line">    mSystemServiceManager.setStartInfo(mRuntimeRestart, mRuntimeStartElapsedTime, mRuntimeStartUptime);</span><br><span class="line">    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line">    <span class="comment">// 4.服务根据优先级被分成3批来启动：</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        t.traceBegin(<span class="string">&quot;StartServices&quot;</span>);</span><br><span class="line">        <span class="comment">//启动引导服务</span></span><br><span class="line">        startBootstrapServices(t);</span><br><span class="line">        <span class="comment">//启动核心服务</span></span><br><span class="line">        startCoreServices(t);</span><br><span class="line">         <span class="comment">//启动其他服务</span></span><br><span class="line">        startOtherServices(t);</span><br><span class="line">        <span class="comment">//启动 APEX 服务</span></span><br><span class="line">		startApexServices(t);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Slog.e(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;******************************************&quot;</span>);</span><br><span class="line">        Slog.e(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;************ Failure starting system services&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        t.traceEnd(); <span class="comment">// StartServices</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 5.开启looper循环</span></span><br><span class="line">     Looper.loop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-4-System-Server启动的主要服务"><a href="#3-4-System-Server启动的主要服务" class="headerlink" title="3.4 System Server启动的主要服务"></a>3.4 System Server启动的主要服务</h3><p>以下为System Server启动的主要服务列表，具体实现可在源码中查看。</p>
<table>
<thead>
<tr>
<th>服务名称</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>Activity Manager Service (AMS)</td>
<td>管理应用程序的生命周期，包括启动和停止应用、管理任务和活动栈、处理广播等</td>
</tr>
<tr>
<td>Package Manager Service (PMS)</td>
<td>管理应用包的安装、卸载、更新、权限分配等</td>
</tr>
<tr>
<td>System Config Service</td>
<td>管理系统配置和资源</td>
</tr>
<tr>
<td>Power Manager Service</td>
<td>管理设备的电源状态和电源策略，如休眠、唤醒等</td>
</tr>
<tr>
<td>Display Manager Service</td>
<td>管理显示设备，如屏幕亮度、显示模式等</td>
</tr>
<tr>
<td>User Manager Service</td>
<td>管理用户账户和用户信息</td>
</tr>
<tr>
<td>Battery Service</td>
<td>监控和管理电池状态和电池使用情况</td>
</tr>
<tr>
<td>Vibrator Service</td>
<td>控制设备的振动功能</td>
</tr>
<tr>
<td>Sensor Service</td>
<td>管理设备的传感器，如加速度计、陀螺仪等</td>
</tr>
<tr>
<td>Window Manager Service (WMS)</td>
<td>管理窗口和显示内容，包括窗口的创建、删除、布局等</td>
</tr>
<tr>
<td>Input Manager Service</td>
<td>管理输入设备，如触摸屏、键盘等</td>
</tr>
<tr>
<td>Alarm Manager Service</td>
<td>提供定时任务调度功能</td>
</tr>
<tr>
<td>Connectivity Service</td>
<td>管理网络连接，如 Wi-Fi、移动数据等</td>
</tr>
<tr>
<td>Network Management Service</td>
<td>管理网络接口和网络连接</td>
</tr>
<tr>
<td>Telephony Registry</td>
<td>管理电话和短信服务</td>
</tr>
<tr>
<td>Input Method Manager Service (IMMS)</td>
<td>管理输入法框架</td>
</tr>
<tr>
<td>Accessibility Manager Service</td>
<td>管理无障碍服务，为有特殊需要的用户提供辅助功能</td>
</tr>
<tr>
<td>Mount Service</td>
<td>管理存储设备的挂载和卸载</td>
</tr>
<tr>
<td>Location Manager Service</td>
<td>管理位置服务，如 GPS 和网络定位</td>
</tr>
<tr>
<td>Search Manager Service</td>
<td>管理系统搜索功能</td>
</tr>
<tr>
<td>Clipboard Service</td>
<td>管理剪贴板功能</td>
</tr>
<tr>
<td>DevicePolicy Manager Service</td>
<td>管理设备的安全策略和企业管理功能</td>
</tr>
<tr>
<td>Status Bar Service</td>
<td>管理状态栏显示和操作</td>
</tr>
<tr>
<td>Wallpaper Manager Service</td>
<td>管理壁纸设置和操作</td>
</tr>
<tr>
<td>Media Router Service</td>
<td>管理媒体设备路由</td>
</tr>
</tbody></table>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>Android系统启动的核心流程如下：</p>
<ol>
<li>Linux内核启动</li>
<li>init进程启动</li>
<li>init进程fork出Zygote进程</li>
<li>Zygote进程fork出SystemServer进程</li>
<li>SystemServer进程启动各项服务（PMS、AMS等）</li>
<li>AMS服务启动Launcher桌面</li>
</ol>
<img src="/2024/09/26/Android%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/93a0c5f6ec004422bacfbdfa59a4f9d1tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-1726732260395-5-1726732261497-7.webp" class="" title="93a0c5f6ec004422bacfbdfa59a4f9d1tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-1726732260395-5-1726732261497-7">

<p>参考文章：</p>
<p><a href="https://juejin.cn/post/6969141197596000263">Android系统启动流程（基于Android 11）</a></p>
<p><a href="https://www.cnblogs.com/anywherego/p/18221943">Android启动过程-万字长文(Android14)</a></p>
<p><a href="http://gityuan.com/android/">http://gityuan.com/android/</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder原理浅析</title>
    <url>/2024/09/27/Binder%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Binder原理浅析"><a href="#Binder原理浅析" class="headerlink" title="Binder原理浅析"></a>Binder原理浅析</h1><h2 id="一、Binder优势"><a href="#一、Binder优势" class="headerlink" title="一、Binder优势"></a>一、Binder优势</h2><table>
<thead>
<tr>
<th><strong>优势</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>性能</td>
<td>一次数据拷贝，mmap内存映射</td>
</tr>
<tr>
<td>稳定性</td>
<td>基于 C&#x2F;S 架构，架构清晰、职责明确</td>
</tr>
<tr>
<td>安全性</td>
<td>为每个APP分配UID，鉴别进程身份的重要标志，阻止恶意程序通过猜测接收方地址获得连接</td>
</tr>
</tbody></table>
<h2 id="二、Binder概要设计"><a href="#二、Binder概要设计" class="headerlink" title="二、Binder概要设计"></a>二、Binder概要设计</h2><h3 id="2-1、进程隔离"><a href="#2-1、进程隔离" class="headerlink" title="2.1、进程隔离"></a>2.1、进程隔离</h3><ul>
<li>操作系统中，进程与进程间内存是不共享的。<strong>两个进程就像两个平行的世界，A 进程没法直接访问 B 进程的数据</strong>，这就是进程隔离的通俗解释。A 进程和 B 进程之间要进行数据交互就得采用特殊的通信机制：进程间通信（IPC）。</li>
</ul>
<style>.jgbgrxqwssew{zoom:50%;}</style><img src="/2024/09/27/Binder%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/e7bd0de241c94a04a92bb46e0529b414tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" class="jgbgrxqwssew" alt="img">

<ul>
<li>操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。为了保证安全性，它们之间是隔离的，用户空间需要经过<strong>系统调用</strong>才能访问到内核空间。</li>
</ul>
<h3 id="2-2、Binder通信模型"><a href="#2-2、Binder通信模型" class="headerlink" title="2.2、Binder通信模型"></a>2.2、Binder通信模型</h3><p>Binder由四个组件<strong>Client</strong>、<strong>Server</strong>、<strong>Service Manager</strong>和<strong>Binder驱动程序</strong>组成</p>
<img src="/2024/09/27/Binder%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/v2-729b3444cd784d882215a24067893d0e_720w.webp" class="" title="img">

<ol>
<li>Client、Server和Service Manager实现在用户空间中，Binder驱动程序实现在内核空间中</li>
<li>Binder驱动程序和Service Manager在Android平台中已经实现，开发者只需要在用户空间实现自己的Client和Server</li>
<li>Binder驱动程序提供设备文件&#x2F;dev&#x2F;binder与用户空间交互，Client、Server和Service Manager通过open和ioctl文件操作函数与Binder驱动程序进行通信</li>
<li>Client和Server之间的进程间通信通过Binder驱动程序间接实现</li>
<li>Service Manager是一个守护进程，用来管理Server，并向Client提供查询Server接口的能力</li>
</ol>
<h3 id="2-3、Binder通信过程"><a href="#2-3、Binder通信过程" class="headerlink" title="2.3、Binder通信过程"></a>2.3、Binder通信过程</h3><ol>
<li>首先，一个进程使用 BINDER_SET_CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；</li>
<li>Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</li>
<li>Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。</li>
</ol>
<p>我们看到整个通信过程都需要 Binder 驱动的接入。下图能更加直观的展现整个通信过程(为了进一步抽象通信过程以及呈现上的方便，下图我们忽略了 Binder 实体及其引用的概念)：</p>
<img src="/2024/09/27/Binder%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/v2-67854cdf14d07a6a4acf9d675354e1ff_720w.webp" class="" title="img">

<h3 id="2-4、Binder实现过程"><a href="#2-4、Binder实现过程" class="headerlink" title="2.4、Binder实现过程"></a>2.4、Binder实现过程</h3><h4 id="2-4-1、-实现图解"><a href="#2-4-1、-实现图解" class="headerlink" title="2.4.1、 实现图解"></a>2.4.1、 实现图解</h4><p>client请求service服务，比如说Activity请求Activity ManagerService服务，由于Activity和ActivityManagerService是在两个不同的进程中的，那么下图是一个很直观的请求过程。</p>
<img src="/2024/09/27/Binder%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/1714aed6f1fc5a80tplv-t2oaga2asx-jj-mark3024000q75.webp" class="" title="在这里插入图片描述">

<p><strong>但是注意</strong>，一个进程是不能直接直接操作另一个进程的，比如说读取另一个进程的数据，或者往另一个进程的内存空间写数据，进程之间的通信要通过内核进程才可以，因此这里就要使用到进程通信工具Binder了如下图：</p>
<img src="/2024/09/27/Binder%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/1714aed6e9373ce5tplv-t2oaga2asx-jj-mark3024000q75.webp" class="" title="在这里插入图片描述">

<p><strong>但是</strong>上面还有个问题就是client和service要直接和binder driver打交道，但是实际上client和service并不想知道binder相关协议，所以进一步client通过添加proxy代理，service通过添加stub来进一步处理与binder的交互。</p>
<img src="/2024/09/27/Binder%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/1714aed6e959b77etplv-t2oaga2asx-jj-mark3024000q75.webp" class="" title="在这里插入图片描述">

<p>这样的好处是client和service都可以不用直接去和binder打交道。上面的图好像已经很完善了，但是Android系统更进一步封装，不让client知道Binder的存在，Android系统提供了Manager来管理client。如下图：</p>
<img src="/2024/09/27/Binder%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/1714aed729e2b6e4tplv-t2oaga2asx-jj-mark3024000q75.webp" class="" title="在这里插入图片描述">

<p>这样client只需要交给manager来管理就好了，根本就不用关心进程通信相关的事，关于manager其实是很熟悉的，比如说activity的就是由ActivityManager来控制的，ActivityManager是通过Binder获取ActivityManagerService来控制activity的。这样就不用我们自己来使用Binder来ActivityManagerService通信了。</p>
<p>更进一步，client是如何具体获取到哪个service的呢？如下图所示：</p>
<img src="/2024/09/27/Binder%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/1714aed72270d98etplv-t2oaga2asx-jj-mark3024000q75.webp" class="" title="在这里插入图片描述">

<p>在service和binder之间还有一个contextManager，也就是serviceManager，每一个service要先往serviceManager里面进行注册，注册完成之后由serviceManager统一管理。 在Android studio中可以通过adb指定打印出当前已经注册过serviceManager的service。</p>
<h4 id="2-4-2、实现示例"><a href="#2-4-2、实现示例" class="headerlink" title="2.4.2、实现示例"></a>2.4.2、实现示例</h4><p>示例调用流程如下：</p>
<img src="/2024/09/27/Binder%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/5ecf5179cc274c4c8c1e726013ca04d7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" class="" title="img">

<h5 id="2-4-2-1-客户端Activity"><a href="#2-4-2-1-客户端Activity" class="headerlink" title="2.4.2.1 客户端Activity"></a>2.4.2.1 客户端Activity</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NoAidlActivity.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MyService.class);</span><br><span class="line"></span><br><span class="line">    bindService(intent, <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> &#123;</span><br><span class="line">            <span class="comment">//1. 从对象池拿到可复用的对象（享元模式）</span></span><br><span class="line">            <span class="type">Parcel</span> <span class="variable">data</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">            <span class="type">Parcel</span> <span class="variable">reply</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line"></span><br><span class="line">            Log.e(<span class="string">&quot;哈利迪&quot;</span>, <span class="string">&quot;--- 我是客户端 NoAidlActivity , pid = &quot;</span></span><br><span class="line">                  + Process.myPid() + <span class="string">&quot;, thread = &quot;</span></span><br><span class="line">                  + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;666&quot;</span>;</span><br><span class="line">            Log.e(<span class="string">&quot;哈利迪&quot;</span>, <span class="string">&quot;客户端向服务端发送：&quot;</span> + str);</span><br><span class="line">            <span class="comment">//2. 往data写数据，作为请求参数</span></span><br><span class="line">            data.writeString(str);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3. 拿到服务端的IBinder句柄，调用transact</span></span><br><span class="line">            <span class="comment">//约定行为码是1；需要服务端的返回值，所以flags传0表示同步调用</span></span><br><span class="line">            service.transact(<span class="number">1</span>, data, reply, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            Log.e(<span class="string">&quot;哈利迪&quot;</span>, <span class="string">&quot;--- 我是客户端 NoAidlActivity , pid = &quot;</span></span><br><span class="line">                  + Process.myPid() + <span class="string">&quot;, thread = &quot;</span></span><br><span class="line">                  + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4. 从reply读取服务端的返回值</span></span><br><span class="line">            Log.e(<span class="string">&quot;哈利迪&quot;</span>, <span class="string">&quot;客户端接收服务端返回：&quot;</span> + reply.readString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, Context.BIND_AUTO_CREATE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如上代码，主要查看步骤2与步骤3。写入参数’666’至data，service.transact把data作为参数传递。</p>
<h5 id="2-4-2-2-服务端运行的Service"><a href="#2-4-2-2-服务端运行的Service" class="headerlink" title="2.4.2.2 服务端运行的Service"></a>2.4.2.2 服务端运行的Service</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="comment">//返回服务端的IBinder句柄</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBinder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册服务，让服务端Service运行在<code>:remote</code>进程，来实现跨进程</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:name</span>=<span class="string">&quot;.binder.no_aidl.MyService&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:process</span>=<span class="string">&quot;:remote&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行在服务端的Binder对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyBinder</span> <span class="keyword">extends</span> <span class="title class_">Binder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, Parcel data, Parcel reply, <span class="type">int</span> flags)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">1</span>) &#123;<span class="comment">//如果是约定好的行为码1</span></span><br><span class="line">            Log.e(<span class="string">&quot;哈利迪&quot;</span>, <span class="string">&quot;--- 我是服务端 MyBinder , pid = &quot;</span></span><br><span class="line">                  + Process.myPid() + <span class="string">&quot;, thread = &quot;</span></span><br><span class="line">                  + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//1. 从data读取客户端参数</span></span><br><span class="line">            Log.e(<span class="string">&quot;哈利迪&quot;</span>, <span class="string">&quot;服务端收到：&quot;</span> + data.readString());</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;777&quot;</span>;</span><br><span class="line">            Log.e(<span class="string">&quot;哈利迪&quot;</span>, <span class="string">&quot;服务端返回：&quot;</span> + str);</span><br><span class="line">            <span class="comment">//2. 从reply向客户端写返回值</span></span><br><span class="line">            reply.writeString(str);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3. 处理完成</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出日志</p>
<img src="/2024/09/27/Binder%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/b648c0439d854405b3189bc6d5079c9ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" class="" title="img">

<p>Binder机制使用了<strong>Parcel来序列化数据</strong>，客户端在主线程调用了<strong>transact来请求</strong>（Parcel data传参），服务端在<strong>Binder线程</strong>调用<strong>onTransact来响应</strong>（Parcel reply回传结果）。</p>
<h2 id="三、Binder源码流程"><a href="#三、Binder源码流程" class="headerlink" title="三、Binder源码流程"></a>三、Binder源码流程</h2><h3 id="3-1、Binder的调用流程图"><a href="#3-1、Binder的调用流程图" class="headerlink" title="3.1、Binder的调用流程图"></a>3.1、Binder的调用流程图</h3><img src="/2024/09/27/Binder%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/1714ed5c901bcca2tplv-t2oaga2asx-jj-mark3024000q75.webp" class="" title="在这里插入图片描述">

<h3 id="3-2、客户端与驱动交互"><a href="#3-2、客户端与驱动交互" class="headerlink" title="3.2、客户端与驱动交互"></a>3.2、客户端与驱动交互</h3><p>先来看客户端与驱动的交互。因为是跨进程调用（指定了<code>:remote</code>），示例里onServiceConnected回调回来的service对象是个BinderProxy代理实例（不跨进程的话会发生<code>远程转本地</code>，后面讲），我们以service.transact(1, data, reply, 0)这行调用作为入口跟进。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BinderProxy.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transact</span><span class="params">(<span class="type">int</span> code, Parcel data, Parcel reply, <span class="type">int</span> flags)</span>&#123;</span><br><span class="line">    <span class="comment">//调用了native方法</span></span><br><span class="line">    <span class="keyword">return</span> transactNative(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个native方法在<a href="https://www.androidos.net.cn/android/8.0.0_r4/xref/frameworks/base/core/jni/android_util_Binder.cpp">android_util_Binder.cpp</a>里注册</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android_util_Binder.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//JNI注册</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> JNINativeMethod gBinderProxyMethods[] = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;transactNative&quot;</span>,</span><br><span class="line">     <span class="string">&quot;(ILandroid/os/Parcel;Landroid/os/Parcel;I)Z&quot;</span>,</span><br><span class="line">     (<span class="type">void</span>*)android_os_BinderProxy_transact&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//native方法具体实现</span></span><br><span class="line"><span class="function"><span class="type">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jint code, jobject dataObj, jobject replyObj, jint flags)</span></span>&#123;</span><br><span class="line">    <span class="comment">//转成native层的Parcel</span></span><br><span class="line">    Parcel* data = <span class="built_in">parcelForJavaObject</span>(env, dataObj);</span><br><span class="line">    Parcel* reply = <span class="built_in">parcelForJavaObject</span>(env, replyObj);</span><br><span class="line">    <span class="comment">//拿到native层的句柄BpBinder</span></span><br><span class="line">    IBinder* target = (IBinder*)</span><br><span class="line">        env-&gt;<span class="built_in">GetLongField</span>(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    <span class="comment">//调用BpBinder的transact</span></span><br><span class="line">    <span class="type">status_t</span> err = target-&gt;<span class="built_in">transact</span>(code, *data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟<a href="https://www.androidos.net.cn/android/8.0.0_r4/xref/frameworks/native/libs/binder/BpBinder.cpp">BpBinder.cpp</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BpBinder.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    <span class="comment">//交给线程单例处理，驱动会根据mHandle值来找到对应的binder句柄</span></span><br><span class="line">    <span class="type">status_t</span> status = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">        mHandle, code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IPCThreadState是一个<strong>线程单例</strong>，负责与binder驱动进行具体的指令通信，跟进<a href="https://www.androidos.net.cn/android/8.0.0_r4/xref/frameworks/native/libs/binder/IPCThreadState.cpp">IPCThreadState.cpp</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IPCThreadState.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将数据写入mOut，见1.1</span></span><br><span class="line">    err = <span class="built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...先忽略one way异步调用的代码，只看有返回值的同步调用</span></span><br><span class="line">    <span class="comment">//跟binder驱动交互，传入reply接收返回数据，见1.2</span></span><br><span class="line">    err = <span class="built_in">waitForResponse</span>(reply);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.1 将数据写入mOut</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line">    <span class="comment">//...打包各种数据（data size、buffer、offsets）</span></span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//将BC_TRANSACTION指令写入mOut</span></span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(cmd);</span><br><span class="line">    <span class="comment">//将打包好的binder_transaction_data写入mOut</span></span><br><span class="line">    mOut.<span class="built_in">write</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.2 跟binder驱动交互，传入reply接收返回数据</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这个循环很重要，客户端就是在这里休眠等待服务端返回结果的</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//跟驱动进行数据交互，往驱动写mOut，从驱动读mIn，见1.3</span></span><br><span class="line">        <span class="built_in">talkWithDriver</span>();</span><br><span class="line">        <span class="comment">//读取驱动回复的指令</span></span><br><span class="line">        cmd = (<span class="type">uint32_t</span>)mIn.<span class="built_in">readInt32</span>();</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">                <span class="comment">//表示驱动已经收到客户端的transact请求</span></span><br><span class="line">                <span class="comment">//如果是one way异步调用，到这就可以结束了</span></span><br><span class="line">                <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">                <span class="comment">//表示客户端收到服务端的返回结果</span></span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                <span class="comment">//把服务端的数据读出来，打包进tr</span></span><br><span class="line">                err = mIn.<span class="built_in">read</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line">                <span class="comment">//再把tr的数据透传进reply</span></span><br><span class="line">                reply-&gt;<span class="built_in">ipcSetDataReference</span>(...);</span><br><span class="line">                <span class="comment">//结束</span></span><br><span class="line">                <span class="keyword">goto</span> finish;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.3 跟驱动进行数据交互，往驱动写mOut，从驱动读mIn</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="type">bool</span> doReceive)</span></span>&#123;</span><br><span class="line">    binder_write_read bwr;</span><br><span class="line">    <span class="comment">//指定写数据大小和写缓冲区</span></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="type">uintptr_t</span>)mOut.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定读数据大小和读缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.<span class="built_in">dataCapacity</span>();</span><br><span class="line">        bwr.read_buffer = (<span class="type">uintptr_t</span>)mIn.<span class="built_in">data</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ioctl的调用进入了binder驱动层的binder_ioctl</span></span><br><span class="line">    <span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//数据已经写入驱动，从mOut移除</span></span><br><span class="line">        <span class="keyword">if</span> (bwr.write_consumed &lt; mOut.<span class="built_in">dataSize</span>())</span><br><span class="line">            mOut.<span class="built_in">remove</span>(<span class="number">0</span>, bwr.write_consumed);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            mOut.<span class="built_in">setDataSize</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//从驱动读出数据存入mIn</span></span><br><span class="line">        mIn.<span class="built_in">setDataSize</span>(bwr.read_consumed);</span><br><span class="line">        mIn.<span class="built_in">setDataPosition</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ioctl的调用进入了<strong>binder驱动层的binder_ioctl</strong></p>
<h3 id="3-3、服务端与驱动交互"><a href="#3-3、服务端与驱动交互" class="headerlink" title="3.3、服务端与驱动交互"></a>3.3、服务端与驱动交互</h3><p>服务端创建了一个线程注册进binder驱动，即binder线程，在<a href="https://www.androidos.net.cn/android/8.0.0_r4/xref/frameworks/native/libs/binder/ProcessState.cpp">ProcessState.cpp</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IPCThreadState.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IPCThreadState::joinThreadPool</span><span class="params">(<span class="type">bool</span> isMain)</span></span>&#123;</span><br><span class="line">    <span class="comment">//向binder驱动写数据，表示当前线程需要注册进binder驱动</span></span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</span><br><span class="line">    <span class="type">status_t</span> result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//进入死循环，等待指令的到来，见1.1</span></span><br><span class="line">        result = <span class="built_in">getAndExecuteCommand</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span> (result != -ECONNREFUSED &amp;&amp; result != -EBADF);</span><br><span class="line">    <span class="comment">//向binder驱动写数据（退出循环，线程结束）</span></span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(BC_EXIT_LOOPER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.1 等待指令的到来</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::getAndExecuteCommand</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//跟驱动进行数据交互，驱动会把指令写进mIn</span></span><br><span class="line">    <span class="built_in">talkWithDriver</span>();</span><br><span class="line">    <span class="comment">//从mIn读出指令</span></span><br><span class="line">    cmd = mIn.<span class="built_in">readInt32</span>();</span><br><span class="line">    <span class="comment">//执行指令，见1.2</span></span><br><span class="line">    result = <span class="built_in">executeCommand</span>(cmd);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.2 执行指令</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::executeCommand</span><span class="params">(<span class="type">int32_t</span> cmd)</span></span>&#123;</span><br><span class="line">    <span class="comment">//客户端发请求到驱动，驱动转发到服务端</span></span><br><span class="line">    <span class="keyword">switch</span> ((<span class="type">uint32_t</span>)cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION:&#123;</span><br><span class="line">            <span class="comment">//服务端收到BR_TRANSACTION指令</span></span><br><span class="line">            binder_transaction_data tr;</span><br><span class="line">            <span class="comment">//读出客户端请求的参数</span></span><br><span class="line">            result = mIn.<span class="built_in">read</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//准备数据，向上传给Java层</span></span><br><span class="line">            Parcel buffer; Parcel reply;</span><br><span class="line">            buffer.<span class="built_in">ipcSetDataReference</span>(...);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//cookie保存的是binder实体，对应服务端的native层对象就是BBinder</span></span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;<span class="built_in">transact</span>(tr.code, buffer,</span><br><span class="line">                                                            &amp;reply, tr.flags);</span><br><span class="line">            <span class="comment">//服务端向驱动写返回值，让驱动转发给客户端</span></span><br><span class="line">            <span class="built_in">sendReply</span>(reply, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.3 服务端向驱动写返回值，让驱动转发给客户端</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::sendReply</span><span class="params">(<span class="type">const</span> Parcel&amp; reply, <span class="type">uint32_t</span> flags)</span></span>&#123;</span><br><span class="line">    err = <span class="built_in">writeTransactionData</span>(BC_REPLY, flags, <span class="number">-1</span>, <span class="number">0</span>, reply, &amp;statusBuffer);</span><br><span class="line">    <span class="comment">//服务端返回结果给客户端就行，不用等待客户端，所以传NULL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">waitForResponse</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后看下BBinder的transact是怎么向上传递到Java层的，在<a href="https://www.androidos.net.cn/android/8.0.0_r4/xref/frameworks/native/libs/binder/Binder.cpp">Binder.cpp</a>中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Binder.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BBinder::transact</span><span class="params">(<span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, </span></span></span><br><span class="line"><span class="params"><span class="function">                           Parcel* reply, <span class="type">uint32_t</span> flags)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            <span class="comment">//ping指令用来判断连通性，即binder句柄是否还活着</span></span><br><span class="line">        <span class="keyword">case</span> PING_TRANSACTION:</span><br><span class="line">            reply-&gt;<span class="built_in">writeInt32</span>(<span class="built_in">pingBinder</span>());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//看这，通过JNI调用到Java层的execTransact，见1.1</span></span><br><span class="line">            err = <span class="built_in">onTransact</span>(code, data, reply, flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//android_util_Binder.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.1 通过JNI调用到Java层的execTransact</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">onTransact</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    JNIEnv* env = <span class="built_in">javavm_to_jnienv</span>(mVM);</span><br><span class="line">    jboolean res = env-&gt;<span class="built_in">CallBooleanMethod</span>(mObject, gBinderOffsets.mExecTransact, ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到Java层，execTransact如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//android.os.Binder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">execTransact</span><span class="params">(...)</span> &#123;</span><br><span class="line">    res = onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>额外Binder问题</strong></p>
<p>1、<a href="https://www.jianshu.com/p/ea4fc6aefaa8">[007]一次Binder通信最大可以传输多大的数据？</a></p>
<img src="/2024/09/27/Binder%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/image-20240927165800594.png" class="" title="image-20240927165800594">

<p>2、<a href="https://blog.csdn.net/maniuT/article/details/132000536">Android跨进程传大图思考及实现——附上原理分析</a></p>
<p>1.Binder驱动给每个进程<strong>最多分配4M</strong>的buffer空间大小；<br>2.异步事务的空闲缓冲区空间大小<strong>最多为2M</strong>；<br>3.Binder内核内存上限为<strong>1M-8k</strong>;<br>4.异步事务缓冲区空间大小等于<strong>buffer_size&#x2F;2</strong>，具体值取决于<strong>buffer_size</strong>; </p>
<p>TODO：Binder内核、IPCThreadState相关知识点的整理</p>
<p><strong>参考资料：</strong></p>
<p> <a href="https://www.freesion.com/article/69441396225/" title="https://my.oschina.net/wolfcs/blog/209421">Android Binder 线程</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/35519585">写给 Android 应用工程师的 Binder 原理剖析</a></p>
<p><a href="https://juejin.cn/post/6890088205916307469">图解 | 不得错过的Binder浅析（一）</a></p>
<p><a href="https://juejin.cn/post/6844904115777044488#comment">图解Android中的binder机制</a></p>
<p><a href="https://my.oschina.net/youranhongcha/blog/149578">红茶一杯话 Binder（ServiceManager 篇）</a></p>
<p><a href="https://blog.csdn.net/luoshengyang/article/details/6618363">Android进程间通信（IPC）机制Binder简要介绍和学习计划（罗升阳）</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title>C++双冒号::的作用</title>
    <url>/2024/09/27/C%E5%8F%8C%E5%86%92%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h3 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h3><p>全局命名空间是一个包含所有全局变量、函数和类型的<span style="color: #ff0000;">隐式命名空间</span>。如果想要在一个局部作用域内访问全局作用域的实体，可以使用双冒号<code>::</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> var = <span class="number">10</span>; <span class="comment">// global variable</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">20</span>; <span class="comment">// local variable</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Global var: &quot;</span> &lt;&lt; ::var &lt;&lt; std::endl; <span class="comment">// 全局参数var</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Local var: &quot;</span> &lt;&lt; var &lt;&lt; std::endl; <span class="comment">// 局部参数var </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> zhou; <span class="comment">//全局变量 </span></span><br><span class="line"><span class="type">void</span> sleep（） </span><br><span class="line">｛ </span><br><span class="line"><span class="type">char</span> zhou; <span class="comment">//局部变量 </span></span><br><span class="line"><span class="built_in">char</span>(局部变量) = <span class="built_in">char</span>(局部变量) *<span class="built_in">char</span>(局部变量) ; </span><br><span class="line">::<span class="built_in">char</span>(全局变量) =::<span class="built_in">char</span>(全局变量) *<span class="built_in">char</span>(局部变量); </span><br><span class="line">｝ </span><br></pre></td></tr></table></figure>

<p><span style="color: #4d4d4d;">上述代码中，全局变量和局部变量同名。通过</span><code>::</code><span style="color: #4d4d4d;">运算符，我们可以明确地引用全局变量。</span></p>
<p>&nbsp;</p>
<h3 id="类成员访问"><a href="#类成员访问" class="headerlink" title="类成员访问"></a>类成员访问</h3><p>在C++中，双冒号<code>::</code>也用于访问类的<span style="color: #ff0000;">静态成员</span>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">static_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Static function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::static_var = <span class="number">10</span>; <span class="comment">// define static member outside the class</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Static var: &quot;</span> &lt;&lt; MyClass::static_var &lt;&lt; std::endl;</span><br><span class="line">    MyClass::<span class="built_in">static_function</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><span style="color: #4d4d4d;">在上述代码中，</span><code>::</code><span style="color: #4d4d4d;">被用来访问类的静态成员。注意静态成员需要在类外部定义。</span></p>
<p>&nbsp;</p>
<h3 id="命名空间访问"><a href="#命名空间访问" class="headerlink" title="命名空间访问"></a>命名空间访问</h3><p>双冒号<code>::</code>还被用于明确指定某个命名空间中的实体。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MyNamespace &#123;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Function in namespace&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&lt;span style=<span class="string">&quot;color: #7f7f7f&quot;</span>&gt;指定某个命名空间中的实体&lt;/span&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Var: &quot;</span> &lt;&lt; MyNamespace::var &lt;&lt; std::endl;</span><br><span class="line">    MyNamespace::<span class="built_in">function</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><span style="color: #4d4d4d;">在上述代码中，</span><code>::</code><span style="color: #4d4d4d;">被用来访问特定命名空间中的变量和函数。</span></p>
<p>&nbsp;</p>
<h3 id="解决名称冲突"><a href="#解决名称冲突" class="headerlink" title="解决名称冲突"></a>解决名称冲突</h3><p>.<span style="color: #4d4d4d;">双冒号</span><code>::</code><span style="color: #4d4d4d;">还可以用于解决名称冲突，例如当使用了相同名称的两个库时。</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Library1 &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Print from Library1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Library2 &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Print from Library2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Library1::<span class="built_in">print</span>();</span><br><span class="line">    Library2::<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类方法定义"><a href="#类方法定义" class="headerlink" title="类方法定义"></a>类方法定义</h3><p><span style="color: #4d4d4d;"><span style="color: #4d4d4d;">前面一般是类名称，后面一般是该类的成员名称，C++为例避免不同的类有名称相同的成员而采用作用域的方式进行区分</span><br><span style="color: #4d4d4d;">如：A,B表示两个类，在A,B中都有成员member。那么</span><br><span style="color: #4d4d4d;">A::member就表示类A中的成员member</span><br><span style="color: #4d4d4d;">B::member就表示类B中的成员member</span></span></p>
<p><span style="color: #4d4d4d;">比如声明了一个类A，类A里声明了一个成员函数voidf()，但没有在类的声明里给出f的定义，那么在类外定义f时，就要写成voidA::f()，表示这个f()函数是类A的成员函数。例如</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CA</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  <span class="type">int</span> ca_var;  </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;  </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a)</span></span>;  </span><br><span class="line">&#125;; </span><br><span class="line">  </span><br><span class="line"><span class="comment">//那么在实现这个函数时，必须这样书写：  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CA::add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> a + b;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//另外，双冒号也常常用于在类变量内部作为当前类实例的元素进行表示，比如:  </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CA::add</span><span class="params">(<span class="type">int</span> a)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> a + ::ca_var;  </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">//表示当前类实例中的变量ca_var。</span></span><br></pre></td></tr></table></figure>

<h3 id="模板类中的双冒号"><a href="#模板类中的双冒号" class="headerlink" title="模板类中的双冒号"></a>模板类中的双冒号</h3><p><span style="color: #4d4d4d;">在模板类中，双冒号用于访问基础模板类的成员。</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T var;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(T x) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;var = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;var = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_base_var</span><span class="params">(MyClass&lt;<span class="type">double</span>&gt;&amp; base_obj)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base var: &quot;</span> &lt;&lt; base_obj.MyClass&lt;<span class="type">double</span>&gt;::var &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><span style="color: #4d4d4d;">在上述代码中，特化的模板类</span><code>MyClass&lt;int&gt;</code><span style="color: #4d4d4d;">使用</span><code>::</code><span style="color: #4d4d4d;">来访问基础模板类</span><code>MyClass&lt;double&gt;</code><span style="color: #4d4d4d;">的成员。</span></p>
<p>&nbsp;</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++基础</tag>
      </tags>
  </entry>
</search>
